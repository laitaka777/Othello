UNIT UnitRechercheSolit;INTERFACE{$PRAGMAC align_array_members on }{$PRAGMAC align power }{$PRAGMAC options align= power }{$PRAGMAC function_align 32}{$ALIGN PowerPC}USES UnitSolitaire,UnitMacExtras;procedure CreeFichierSolitaireGlobal;procedure DoRechercheSolitaires(nroPartiemin,nroPartiemax:longint);IMPLEMENTATION{$PRAGMAC align_array_members on }{$PRAGMAC align power }{$PRAGMAC options align= power }{$PRAGMAC function_align 32}{$ALIGN PowerPC}procedure CreeFichierSolitaireGlobal;const nroRechMin=49;      nroRechMax=49;var fichierglobal,fichierlecture:TEXT;    i,nbreSolitaires:longint;    filename:str255;    procedure OuvreFichierLarge(n:longint);var s:str255;begin  NumToString(n,s);  s := 'disque d: Othello:Solitaires:Solitaire(Large)'+s;  reset(fichierlecture,s);end;procedure TransfertDansGlobal(PasseDesGagnant:boolean);var i,aux,compteur:longint;    uneligne,s:str255;    c:char;begin  reset(fichierlecture);  compteur := 0;  while not(EOF(fichierlecture)) do    begin      readln(fichierlecture,uneligne);      s := '';      for i := 1 to 5 do        begin          c := uneligne[i];          if (c>='0') and (c<='9')             then s := s+c            else s := s+StringOf(' ');        end;      aux := Pos(' N.',uneligne);      if aux>0         then          begin            s := s+TPCopy(uneligne,aux,5);            s := s+StringOf(',')+uneligne[aux+10]+uneligne[aux+11];          end        else          begin            aux := Pos(' B.',uneligne);            s := s+TPCopy(uneligne,aux,5);            s := s+StringOf(',')+uneligne[aux+10]+uneligne[aux+11];          end;      if PasseDesGagnant then        begin          if uneligne[aux+10]<>'0' then            begin              Writeln(fichierglobal,s);              compteur := compteur+1;            end;        end;      if not(PasseDesGagnant) then        begin          if uneligne[aux+10]='0' then            begin              Writeln(fichierglobal,s);              compteur := compteur+1;            end;        end;    end;      nbreSolitaires := nbreSolitaires+compteur;end;  begin  filename := 'disque d: Othello:Solitaires:Solitaires Cassio';  reWrite(fichierglobal,filename);  nbreSolitaires := 0;  for i := nroRechMin to nroRechMax do    begin      OuvreFichierLarge(i);      TransfertDansGlobal(true);      Close(fichierlecture);    end;  WriteStringAndNumAt('solitaires gagnants : ',nbreSolitaires,100,100);  nbreSolitaires := 0;  for i := nroRechMin to nroRechMax do    begin      OuvreFichierLarge(i);      TransfertDansGlobal(false);      Close(fichierlecture);    end;  WriteStringAndNumAt('solitaires nuls : ',nbreSolitaires,100,112);  Close(fichierglobal);  AttendFrappeClavier;end;procedure DoRechercheSolitaires(nroPartiemin,nroPartiemax:longint);const nroRechMin=49;      nroRechMax=49;type t_buffer=packed array[1..260] of t_Octet;     BufferPtr=^t_buffer;var codeErreur:OSErr;    codefichier:integer;    codeFichierSolitaire: array[47..55] of longint;    problemeOuverture: array[47..55] of boolean;    nbreSolitaires: array[47..55] of longint;    s:str255;    filename:str255;    compteur:longint;    NropremierCoup:longint;    nbreSolitairesTotal:longint;    i,nbreJoueurs,nbreParties:longint;    nomJoueur:str19;    nomtournoi:str29;    buffPtr:BufferPtr;    partieBuff:partieDansThorDBAPtr;    count:longint;    TailleTournoiRec,TailleJoueurRec,TaillePartieRec:longint;    TailleHeader,TailleTournois,TailleJoueurs:longint;    platSol:plOth;    nBlaSol,nNoiSol:longint;    trait:longint;    jouableSol,MoveSol:plBool;    frontSol:InfoFrontRec;    profSol,ScoreSol:longint;    mobiliteSol,Xsol,couleurSol:longint;    chainePourBuf:str255;    numeroRecherche:longint;    extension:extended;function RejoueJusquAuCoup(n:longint):boolean;var test:boolean;    x,k:longint;begin  OthellierEtPionsDeDepart(platSol,nBlaSol,nNoiSol);  trait := pionNoir;  k := 0;  with Partiebuff^ do  repeat    k := k+1;    x := coups[k];    if x <> 0 then       begin        test := ModifPlatFin(x,trait,platSol,nBlaSol,nNoiSol);        if test           then            trait := -trait          else             test := ModifPlatFin(x,-trait,platSol,nBlaSol,nNoiSol);      end      else test := false;  until (k>=n) or not(test);  RejoueJusquAuCoup := test;end;        function SolitairePossible(coupmin,coupmax:longint;var nroPremierCoupSol,XduSol,score,mobilite,couleur:longint):boolean;var test,sortieDeBoucle:boolean;    nrocoup,seulCoup,seuleDef:longint;    x,nbremeill,cause:longint;begin  test := false;  x := Partiebuff^.coups[coupmin];  if x>0 then    begin      CarteJouable(platSol,JouableSol);      CarteMove(trait,platSol,MoveSol,mobilite);      if mobilite=0 then        begin          trait := -trait;          CarteMove(trait,platSol,MoveSol,mobilite);        end;      CarteFrontiere(PlatSol,FrontSol);      nrocoup := coupmin;      sortieDeBoucle := false;      repeat                profSol := 64 - nBlaSol - nNoiSol;                        test := EstUnSolitaire(seulCoup,seuleDef,trait,profSol,nblaSol,nNoiSol,                             platSol,jouableSol,frontSol,score,nbremeill,false,cause,kJeuNormal,64);        if test then           begin            nroPremierCoupSol := nrocoup;            XduSol := seulCoup;            couleur := trait;          end;                    nrocoup := nrocoup+1;      until test or (nrocoup>coupmax) or sortieDeBoucle;    end;  SolitairePossible := test;  end;procedure LitPartieNroDansDbaSol(n:longint);  begin      codeErreur := SetFPos(codefichier,1,tailleHeader+TailleTournois+TailleJoueurs+(n-1)*TaillePartieRec);      count := TaillePartieRec;      codeErreur := FSread(codefichier,count,pointer(Partiebuff));      Partiebuff^.numeroTournoi := MySwapInteger(Partiebuff^.numeroTournoi);      Partiebuff^.numeroNoir := MySwapInteger(Partiebuff^.numeroNoir);      Partiebuff^.numeroblanc := MySwapInteger(Partiebuff^.numeroblanc);             end;  procedure LitJoueurNro(n:longint;var nom:str19);var i:longint;  begin      codeErreur := SetFPos(codefichier,1,tailleHeader+TailleTournois+n*TailleJoueurRec);      count := TailleJoueurRec;      codeErreur := FSread(codefichier,count,pointer(buffPtr));      for i := 1 to 19 do        begin          if buffPtr^[i]=0 then buffPtr^[i] := 32;          nom[i] := chr(buffPtr^[i]);        end;      nom[0] := chr(19);  end;     procedure LitTournoiNro(n:longint;var nom:str29);var i:longint;  begin      codeErreur := SetFPos(codefichier,1,tailleHeader+n*TailleTournoiRec);      count := TailleTournoiRec;      codeErreur := FSread(codefichier,count,pointer(buffPtr));      for i := 1 to 29 do        nom[i] := chr(buffPtr^[i]);      nom[0] := chr(29);  end;     procedure InitialiseValeursBaseThor;begin  tailleHeader := 68;  TailleTournoiRec := 32;  TailleJoueurRec := 20;  TailleTournois := 400*TailleTournoiRec;  TailleJoueurs := 2000*TailleJoueurRec;  TaillePartieRec := 68;  count := 4;  codeErreur := FSread(codefichier,count,pointer(buffPtr));  nbreParties := buffPtr^[1]+256*buffPtr^[2];  nbreJoueurs := buffPtr^[3]+256*buffPtr^[4];end;procedure OuvreFichiersSolitaires;var i:longint;    codefic:integer;    codeEr:OSErr;    s:str255;begin  for i := 47 to 55 do    begin      NumToString(i,s);      if SensLargeSolitaire        then s := 'disque d: Othello:Solitaires:Solitaire(Large)'+s        else s := 'disque d: Othello:Solitaires:Solitaire'+s;      codeEr := FSOpen(s,0,codefic);      problemeOuverture[i] := codeEr <> 0;      codeFichierSolitaire[i] := codefic;      codeEr := setFPos(codefic,fsFromLEOF,0);      nbreSolitaires[i] := 0;    end;end;procedure FermeFichiersSolitaires;var i,codeEr:longint;begin  for i := 47 to 55 do    begin      if not(problemeOuverture[i])         then CodeEr := FSclose(codeFichierSolitaire[i]);    end;end;procedure EcritSolitaireDansFic(ligne:str255;nroCoup:longint);var i:longint;    count:longint;    codeErr:OSErr;begin  for i := 1 to Length(ligne) do    buffPtr^[i] := ord(ligne[i]);  buffPtr^[Length(ligne)+1] := 13;   {retour chariot}  count := Length(ligne)+1;  codeErr := FSWrite(codeFichierSolitaire[nroCoup],count,pointer(buffPtr));  if codeerr <> 0 then SysBeep(0);end;procedure LaveFichiersSolitaires;var i:longint;    count,filepos,logEOF:longint;    codeEr:longint;    numFichier:longint;begin  for numFichier := nroRechMin to nroRechMax do    begin      codeEr := setFPos(codeFichierSolitaire[numFichier],fsFromStart,0);      codeEr := getEOF(codeFichierSolitaire[numFichier],logEOF);      repeat        count := 100;        codeEr := FSread(codeFichierSolitaire[numFichier],count,pointer(buffPtr));        for i := 1 to count do if buffPtr^[i]=0 then buffPtr^[i] := 32;        codeEr := setFPos(codeFichierSolitaire[numFichier],fsFromMark,-count);        codeEr := FSWrite(codeFichierSolitaire[numFichier],count,pointer(buffPtr));        codeEr := getFPos(codeFichierSolitaire[numFichier],filepos);       until (count<100) or (filepos>=logEOF);    end;end;begin  SensLargeSolitaire := true;  compteur := nroPartiemin+1;  buffPtr := bufferPtr(AllocateMemoryPtr(sizeof(t_buffer)));  partieBuff := partieDansThorDBAPtr(AllocateMemoryPtr(sizeof(t_partieDansThorDBA)));  if (buffPtr <> NIL) and (partieBuff <> NIL) then     begin       MemoryFillChar(buffPtr,sizeof(buffPtr^),chr(0));       filename := 'disque d: Othello:Solitaires:THOR.DBA';       codeErreur := FSOpen(filename,0,codefichier);       OuvreFichiersSolitaires;              if codeErreur=0 then         begin           InitialiseValeursBaseThor;           nbreSolitairesTotal := 0;                                 compteur := nroPartiemax;           repeat              LitPartieNroDansDbaSol(compteur);              WriteStringAndNumAt('Partie n¡ ',compteur,10,30);              WriteStringAndNumAt('nbre solitaires :',nbreSolitairesTotal,100,30);              if (nbreParties-compteur) <> 0 then                begin                  extension := 1.0*nbreParties*(1.0*(nbreSolitairesTotal)/(nbreParties-compteur));                  WriteStringAndNumAt('soit par extension :',MyTrunc(extension),250,30);                end;                                          for numeroRecherche := nroRechMin to nroRechMax do              if RejoueJusquAuCoup(numeroRecherche-1) then                if SolitairePossible(numeroRecherche,numeroRecherche,NropremierCoup,                                     xSol,scoreSol,mobiliteSol,couleurSol) then             {  if not(SensLargeSolitaire) or (scoreSol>0) then  }                begin                  nbreSolitairesTotal := nbreSolitairesTotal+1;                  nbreSolitaires[NropremierCoup] := nbreSolitaires[NropremierCoup]+1;                                    NumToString(compteur,chainePourBuf);                  if Length(chainePourBuf)<5 then                      for i := 1 to 5-Length(chainePourBuf) do chainePourBuf := StringOf(' ')+chainePourBuf;                  chainePourBuf := chainePourBuf+StringOf(' ');                  LitJoueurNro(Partiebuff^.numeroNoir,nomjoueur);                  for i := 1 to 14 do chainePourBuf := chainePourBuf+nomjoueur[i];                  NumToString(Partiebuff^.scoreEtTheorik[0],s);                  chainePourBuf := chainePourBuf+StringOf(' ')+s+StringOf(' ');                  LitJoueurNro(Partiebuff^.numeroBlanc,nomjoueur);                  for i := 1 to 14 do chainePourBuf := chainePourBuf+nomjoueur[i];                  NumToString(64-Partiebuff^.scoreEtTheorik[0],s);                  chainePourBuf := chainePourBuf+StringOf(' ')+s;                  LitTournoiNro(Partiebuff^.numeroTournoi,nomtournoi);                  chainePourBuf := chainePourBuf+'  '+nomtournoi;                  NumToString(NropremierCoup,s);                  if couleurSol=pionNoir                     then chainePourBuf := chainePourBuf+'   N.'+s+StringOf('.')+CHR(96+xsol mod 10)+CHR(48+xsol div 10)                    else chainePourBuf := chainePourBuf+'   B.'+s+StringOf('.')+CHR(96+xsol mod 10)+CHR(48+xsol div 10);                                    NumToString(scoreSol,s);                  chainePourBuf := chainePourBuf+'=>'+s;                  NumToString(mobiliteSol,s);                  chainePourBuf := chainePourBuf+'  mob: '+s;                                                      EcritSolitaireDansFic(chainePourBuf,NropremierCoup);                  WriteStringAndNumAt(chainePourBuf+'    nb sol: ',nbreSolitaires[NropremierCoup],                                      2,42+12*(nbreSolitairesTotal mod 25));                                  end;                            compteur := compteur-1;           until (compteur=nroPartiemin) or Button() or quitter;                      LaveFichiersSolitaires;           FermeFichiersSolitaires;           codeErreur := FSclose(codefichier);         end;       DisposeMemoryPtr(Ptr(buffPtr));         DisposeMemoryPtr(Ptr(Partiebuff));     end;   if compteur=nroPartiemin then CreeFichierSolitaireGlobal;end;END.
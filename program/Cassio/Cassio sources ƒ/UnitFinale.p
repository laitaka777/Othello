UNIT UnitFinale;INTERFACEUSES UnitUtilitairesFinale,UnitTore,UnitUtilitaires,UnitPhasesPartie,UnitSuperviseur,UnitListeChaineeCasesVides;function CoupGagnantOld(var meilleurX,bstdef,couleurFinale,MFprof,nbBl,nbNo:integer;gameTreeNode:GameTree;                     var jeu:plOth;var empl:plBool;var frontiereFinale:InfoFrontRec;                     MessageHandle:MessageFinaleHdl;var meilleurScore:integer;                     commentaireDansRapport,doitAbsolumentRamenerLaSuite:boolean;                     typeCalculFinale:longint):boolean;            IMPLEMENTATIONprocedure TraiteNullEvent(var theEvent:eventRecord);external; {définie dans UnitAction.p} procedure TraiteOneEvenement; external; {définie dans UnitAction.p} procedure TraiteEvenements;external; {définie dans UnitAction.p} function HasGotEvent(eventMask:EventMask;var theEvent:EventRecord;sleep:UInt32;mouseRgn:RgnHandle):boolean;external; {définie dans UnitAction.p} procedure Calcule_Valeurs_Tactiques(plat:plOth;avecCalculCentre:boolean);external; {définie dans UnitSuperviseur.p}procedure InitialiseConstantesCodagePosition;external;                             {définie dans UnitSuperviseur.p}function Evaluation(var position:plOth;CoulEvaluation,nbBlancs,nbNoirs:integer;                    var jouable:plBool;var front:InfoFrontRec;AfraidOfWipeOut:boolean;                    alpha,beta:integer;var nbEvaluationsRecursives:longint):integer;external; {definie dans UnitEvaluation.p}function AB_simple(var pl:plOth;var joua:plBool;var bstBef:integer;coul,prof,alph,beta,nBla,nNoi:integer;                   var fr:InfoFrontRec;canUseProbCut:boolean):integer;external; {definie dans Unit_AB_simple.p}type  cellulePourListeVide = record                               coup:longint;                               indexDansKiller:longint;                             end;      listeVides = array[1..64] of cellulePourListeVide;type t_InfosMilieuDePartie = record                               frontiere:InfoFrontRec;                               jouable:plBool;                               nbBlancs,nbNoirs:longint;                             end;type DoubleArray = array[0..0] of Double;  {pour pouvoir copier 8 octets à la fois}     DoubleArrayPtr = ^DoubleArray;     LongintArray = array[0..0] of longint; {pour pouvoir copier 4 octets à la fois}     LongintArrayPtr = ^LongintArray;      {$IFC not(GENERATING68K) }const k_Head = 0;      k_NIL  = -1;type  listeChaineeDeCases = array[-1..64] of                               record                                square:longint;                                previous,next:longint;                              end;      tableDePointeurs  = plOthLongint;  {$ENDC}  procedure CopyEnPlOthEndgame(var source:plOth;var dest:plOthEndgame);var i:longint;begin  for i := 0 to 99 do    dest[i] := source[i];end;function ModifPlatFinDiffFastLongint(a,couleur,couleurEnnemie:longint;var jeu:plOthEndgame;var diffPions:longint):boolean;var x1,x2,x3,x4,x5,x6,dx,t,nbprise:longint;begin   nbprise := 0;   for t := dirPriseDeb[a] to dirPriseFin[a] do     begin       dx := dirPrise[t];       x1 := a+dx;       if jeu[x1]=couleurEnnemie then {1}         begin           x2 := x1+dx;           if jeu[x2]=couleurEnnemie then  {2}           begin             x3 := x2+dx;             if jeu[x3]=couleurEnnemie then  {3}		           begin		             x4 := x3+dx;		             if jeu[x4]=couleurEnnemie then  {4}				           begin				             x5 := x4+dx;				             if jeu[x5]=couleurEnnemie then  {5}						           begin						             x6 := x5+dx;						             if jeu[x6]=couleurEnnemie then  {6}								           begin								             if jeu[x6+dx]=couleur then  {seul cas à tester}									             begin									               nbprise := nbprise+12;									               Jeu[x6] := couleur;									               Jeu[x5] := couleur;									               Jeu[x4] := couleur;									               Jeu[x3] := couleur;									               Jeu[x2] := couleur;									               Jeu[x1] := couleur;									             end;								           end								           else								           if jeu[x6]=couleur then								             begin								               nbprise := nbprise+10;								               Jeu[x5] := couleur;								               Jeu[x4] := couleur;								               Jeu[x3] := couleur;								               Jeu[x2] := couleur;								               Jeu[x1] := couleur;								             end;						           end						           else						           if jeu[x5]=couleur then						             begin						               nbprise := nbprise+8;						               Jeu[x4] := couleur;						               Jeu[x3] := couleur;						               Jeu[x2] := couleur;						               Jeu[x1] := couleur;						             end;				           end                   else				           if jeu[x4]=couleur then				             begin				               nbprise := nbprise+6;				               Jeu[x3] := couleur;				               Jeu[x2] := couleur;				               Jeu[x1] := couleur;				             end;		           end		           else		           if jeu[x3]=couleur then		             begin		               nbprise := nbprise+4;		               Jeu[x2] := couleur;		               Jeu[x1] := couleur;		             end;           end           else           if jeu[x2]=couleur then             begin               nbprise := nbprise+2;               Jeu[x1] := couleur;             end;        end;     end;    if (nbprise>0)      then	     begin	       diffPions := succ(diffPions+nbprise);	       jeu[a] := couleur;	       ModifPlatFinDiffFastLongint := true;	     end	   else	     ModifPlatFinDiffFastLongint := false;end;function ModifPlatLongint(a,coul:longint;var jeu:plOth;var jouable:plBool;var nbbl,nbno:longint;var front:InfoFrontRec):boolean;var x,dx,i,k,t,nbprise,nbvideDeX,jeuDeX,whichPattern:longint;    pionEnnemi,compteur:longint;    modifie:boolean;begin   {exeptionnellement, pour le debugage seulement !}   {if (a<11) then Debugger else   if (a>88) then Debugger else   if (jeu[a]<>Pionvide) then Debugger;}   modifie := false;nbprise := 0;   pionEnnemi := -coul;   for t := dirPrisedeb[a] to dirPriseFin[a] do     begin       dx := dirPrise[t];       x := a+dx;       if Jeu[x]=pionEnnemi then         begin           compteur := 0;           repeat             {exeptionnellement, pour le debugage seulement !}             {if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);}             inc(compteur);             x := x+dx;           until Jeu[x]<>pionEnnemi;                      if (Jeu[x]=coul) then             begin               modifie := true;	             x := x-dx;	             for i := 1 to compteur do	               begin	                 Jeu[x] := coul;	                 with front do	                   begin	                     	                     for k := 1 to nbPatternsImpliques[x] do							           begin							             whichPattern := nroPattern[x,k];							             AdressePattern[whichPattern] := AdressePattern[whichPattern]+coul*DoubleDeltaAdresse[x,k];							           end;							                        	                     nbvideDeX := nbvide[x];	                     if nbvideDeX>0 then	                       begin	                         inc(nbfront[coul]);	                         dec(nbfront[-coul]);	                         nbadjacent[coul] := nbadjacent[coul]+nbvideDeX;	                         nbadjacent[-coul] := nbadjacent[-coul]-nbvideDeX;	                       end;	                        	                   end;	                 x := x-dx;      	               end; 	             nbprise := nbprise+compteur;             end;         end;     end;                if modifie then     begin       inc(nbreNoeudsGeneres);               Jouable[a] := false;       jeu[a] := coul;       with front do         begin                    for k := 1 to nbPatternsImpliques[a] do	          begin	            whichPattern := nroPattern[a,k];	            AdressePattern[whichPattern] := AdressePattern[whichPattern]+coul*DeltaAdresse[a,k];	          end;                       if nbvide[a]>0 then inc(nbfront[coul]);          nbadjacent[coul] := nbadjacent[coul]+nbvide[a];          for t := dirPriseDeb[a] to dirPriseFin[a] do            begin               x := a+dirPrise[t];               jeuDeX := jeu[x];               nbvideDeX := nbVide[x];               if nbvideDeX>0 then                   begin                    if nbvideDeX=1 then  {si on vient de prendre la derniere liberte d'une case}                       dec(nbfront[jeuDeX]);                    nbVide[x] := pred(nbvideDeX);                  end;               dec(nbadjacent[jeuDeX]);             end;                      if coul=pionNoir {valeurtact etabli pour Noir}             then begin                 nbNo := nbNo+nbprise+1;                 nbbl := nbbl-nbprise;                 occupationtactique := occupationTactique+valeurTactNoir[a]               end             else begin                 nbNo := nbNo-nbprise;                 nbbl := nbbl+nbprise+1;                 occupationtactique := occupationTactique-valeurTactBlanc[a];               end;                     end;              for t := dirJouabledeb[a] to dirJouablefin[a] do         begin           x := a+dirJouable[t];           Jouable[x] := (Jeu[x]=0);         end;     end;   ModifPlatLongint := modifie;end;function ModifPlatSeulementLongint(a,couleur,couleurEnnemie:longint;var jeu:plOthEndgame):boolean;var x1,x2,x3,x4,x5,x6,dx,t:longint;begin   ModifPlatSeulementLongint := false;   for t := dirPriseDeb[a] to dirPriseFin[a] do     begin       dx := dirPrise[t];       x1 := a+dx;       if jeu[x1]=couleurEnnemie then {1}         begin           x2 := x1+dx;           if jeu[x2]=couleurEnnemie then  {2}           begin             x3 := x2+dx;             if jeu[x3]=couleurEnnemie then  {3}		           begin		             x4 := x3+dx;		             if jeu[x4]=couleurEnnemie then  {4}				           begin				             x5 := x4+dx;				             if jeu[x5]=couleurEnnemie then  {5}						           begin						             x6 := x5+dx;						             if jeu[x6]=couleurEnnemie then  {6}								           begin								             if jeu[x6+dx]=couleur then  {seul cas à tester}									             begin									               Jeu[a] := couleur;									               Jeu[x6] := couleur;									               Jeu[x5] := couleur;									               Jeu[x4] := couleur;									               Jeu[x3] := couleur;									               Jeu[x2] := couleur;									               Jeu[x1] := couleur;									               ModifPlatSeulementLongint := true;									             end;								           end								           else								           if jeu[x6]=couleur then								             begin								               Jeu[a] := couleur;								               Jeu[x5] := couleur;								               Jeu[x4] := couleur;								               Jeu[x3] := couleur;								               Jeu[x2] := couleur;								               Jeu[x1] := couleur;								               ModifPlatSeulementLongint := true;								             end;						           end						           else						           if jeu[x5]=couleur then						             begin						               Jeu[a] := couleur;						               Jeu[x4] := couleur;						               Jeu[x3] := couleur;						               Jeu[x2] := couleur;						               Jeu[x1] := couleur;						               ModifPlatSeulementLongint := true;						             end;				           end                   else				           if jeu[x4]=couleur then				             begin				               Jeu[a] := couleur;				               Jeu[x3] := couleur;				               Jeu[x2] := couleur;				               Jeu[x1] := couleur;				               ModifPlatSeulementLongint := true;				             end;		           end		           else		           if jeu[x3]=couleur then		             begin		               Jeu[a] := couleur;		               Jeu[x2] := couleur;		               Jeu[x1] := couleur;		               ModifPlatSeulementLongint := true;		             end;           end           else           if jeu[x2]=couleur then             begin               Jeu[a] := couleur;               Jeu[x1] := couleur;               ModifPlatSeulementLongint := true;             end;        end;     end; end;function ModifPlatFinLongint(a,coul:longint;var jeu:plOth;var nbbl,nbno:longint):boolean;var x,dx,i,t,nbprise:longint;    pionEnnemi,compteur:longint;    modifie:boolean;begin   modifie := false;nbprise := 0;   pionEnnemi := -coul;   for t := dirPrisedeb[a] to dirPriseFin[a] do     begin       dx := dirPrise[t];       x := a+dx;       if jeu[x]=pionennemi then         begin           compteur := 0;           repeat             inc(compteur);             x := x+dx;                    until jeu[x]<>pionennemi;           if (jeu[x]=coul)then             begin               modifie := true;                for i := 1 to compteur do                 begin                  x := x-dx;                  Jeu[x] := coul;                  end;                nbprise := nbprise+compteur;             end;        end;     end;    if modifie then     begin       if coul=pionNoir          then begin             nbNo := succ(nbNo+nbprise);             nbbl := nbbl-nbprise;           end         else begin             nbNo := nbNo-nbprise;             nbbl := succ(nbbl+nbprise);           end;       jeu[a] := coul;     end;   ModifPlatFinLongint := modifie;end;function CoupGagnantOld(var meilleurX,bstdef,couleurFinale,MFprof,nbBl,nbNo:integer;gameTreeNode:GameTree;                     var jeu:plOth;var empl:plBool;var frontiereFinale:InfoFrontRec;                     MessageHandle:MessageFinaleHdl;var meilleurScore:integer;                     commentaireDansRapport,doitAbsolumentRamenerLaSuite:boolean;                     typeCalculFinale:longint):boolean;var bestMode:boolean;    CoulPourMeilleurFin,coulDefense:longint;         ListeKiller:array[0..nbMaxNiveaux,1..64] of longint;       nbMaxCoupsEnvisages:array[0..nbMaxNiveaux] of longint;    fils:array[11..88] of longint;    move:plBool;    mob:integer;    maxPourOrdonnancement:longint;    classement,classProv:ListOfMoveRecords;    passeDeRechercheAuMoinsNulle:boolean;    FenetreLargePourRechercheScoreExact:boolean;    i,j,k,p,nbCoup,compt:longint;    iCourant:longint;     infini:longint;    defense:longint;    MFniv:longint;    endgameNode:GameTree;    magicCookieEndgameTree:longint;    platClass:plOth;    jouableClass:plBool;    nbBlancClass,nbNoirClass:longint;    frontClass:InfoFrontRec;    noteClass,limSup:longint;    suiteJouee:t_suiteJouee;    meilleureSuite:t_meilleureSuite;    ResultatSansCalcul:boolean;    typeDataDansHandle:longint;    scoreNoirBlanc:integer;    profondeurDepartPreordre,profondeurArretPreordre:longint;    noCoupRecherche:longint;    TempsglobalDeLaFonction:longint;    rechercheDejaAnnonceeDansRapport:boolean;    coupDontLeScoreEstConnu:longint;    scoreDuCoupDontLeScoreEstConnu:longint;    defenseDuCoupDontLeScoreEstConnu:longint;    profForceBrute:longint;         profForceBrutePlusUn:longint;    profTriSelonDivergence:longint;    indexDuCoupDansFntrReflexion:longint;    TickChrono:longint;    InfosPourcentagesCertitudesAffiches:      array[0..3] of record                       mobiliteCetteProf:longint;                       indexDuCoupCetteProf:longint;                       PourcentageAfficheCetteProf:longint;                     end;            function DoitPasserFin(couleur:longint;var plat:plOth):boolean;var a,x,dx,t,adversaire,n:longint;begin  adversaire := -couleur;  for n := 1 to nbcasesvides do    begin      a := casesVides[n];      if plat[a]=pionVide then        for t := dirPriseDeb[a] to dirPriseFin[a] do          begin            dx := dirPrise[t];            x := a+dx;            if plat[x]=adversaire then              begin                repeat                  x := x+dx;                until plat[x]<>adversaire;                if (plat[x]=couleur) then                  begin                    DoitPasserFin := false;                    exit(DoitPasserFin)                  end;              end;          end;    end;  DoitPasserFin := true;end; function DernierCoup(var plat:plOthEndgame;couleur,couleurEnnemie,diffPions:longint):longint;var t,dx,x1,x2,x3,x4,x5,x6,nbprise,iCourant:longint;    {$IFC GENERATING68K} i:longint; {$ENDC}begin  inc(nbreNoeudsGeneresFinale);      {$IFC GENERATING68K }    for i := 1 to nbcasesvides do    BEGIN      iCourant := casesVides[i];                  {$ELSEC}		BEGIN     iCourant := ListeChaineeCasesVides[ListeChaineeCasesVides[k_Head].next].square;         {$ENDC}     if plat[iCourant]=pionVide then         begin          nbprise := 0;        for t := dirPrisedeb[iCourant] to dirPriseFin[iCourant] do          begin            dx := dirPrise[t];            {on calcule les retournements suivant cette direction}            x1 := iCourant+dx;						if plat[x1]=couleurEnnemie then {1}						  begin						    x2 := x1+dx;						    if plat[x2]=couleurEnnemie then  {2}						      begin						        x3 := x2+dx;						        if plat[x3]=couleurEnnemie then  {3}						          begin						            x4 := x3+dx;						            if plat[x4]=couleurEnnemie then  {4}							          begin							            x5 := x4+dx;							            if plat[x5]=couleurEnnemie then  {5}									      begin									        x6 := x5+dx;									        if plat[x6]=couleurEnnemie then  {6}											  begin											    {seul cas à tester}											    if plat[x6+dx]=couleur then nbprise := nbprise+12;											  end											else											  if plat[x6]=couleur then nbprise := nbprise+10;									      end									    else									      if plat[x5]=couleur then nbprise := nbprise+8;							          end						            else							          if plat[x4]=couleur then nbprise := nbprise+6;						          end						        else						          if plat[x3]=couleur then nbprise := nbprise+4;						      end						    else						      if plat[x2]=couleur then nbprise := nbprise+2;						  end;          end;     if (nbprise>0)       then         begin           DernierCoup := succ(diffPions+nbprise);           exit(DernierCoup);               end       else         begin            {nbprise := 0;} {deja Initialise ci-dessus}            for t := dirPriseDeb[iCourant] to dirPriseFin[iCourant] do              begin                dx := dirPrise[t];                {on calcule les retournements suivant cette direction}                x1 := iCourant+dx;	            if plat[x1]=couleur then {1}	              begin	                x2 := x1+dx;	                if plat[x2]=couleur then  {2}	                  begin	                    x3 := x2+dx;	                    if plat[x3]=couleur then  {3}			              begin			                x4 := x3+dx;			                if plat[x4]=couleur then  {4}					          begin					            x5 := x4+dx;					            if plat[x5]=couleur then  {5}							      begin							        x6 := x5+dx;							        if plat[x6]=couleur then  {6}						        begin								      {seul cas à tester}								       if plat[x6+dx]=couleurEnnemie then nbprise := nbprise+12;					          end										else										  if plat[x6]=couleurEnnemie then nbprise := nbprise+10;								      end								    else								      if plat[x5]=couleurEnnemie then nbprise := nbprise+8;						          end		                else						          if plat[x4]=couleurEnnemie then nbprise := nbprise+6;				              end				            else				              if plat[x3]=couleurEnnemie then nbprise := nbprise+4;		                  end		                else		                  if plat[x2]=couleurEnnemie then nbprise := nbprise+2;		              end;	          end;                      if (nbPrise>0)             then              begin                DernierCoup := pred(diffPions-nbprise);                exit(DernierCoup);                    end            else              begin                if diffPions>0 then                   begin                    DernierCoup := succ(diffPions);  {une case vide au vainqueur}                    exit(DernierCoup);                  end;                if diffPions<0 then                   begin                    DernierCoup := pred(diffPions);  {une case vide au vainqueur}                    exit(DernierCoup);                  end;                 DernierCoup := 0;             {nulle}                exit(DernierCoup);              end;        end      end;    END;   DernierCoup := diffPions;  {pas de case vide}end;   { DernierCoup }{ABFinPetite : pour les petites profondeurs ( <= profForceBrute )}function ABFinPetite(var plat:plOthEndgame;couleur,ESprof,alpha,beta,diffPions:longint;vientDePasser:boolean):longint;var platEssai:plOthEndgame;    DiffEssai:longint;    adversaire,profMoins1:longint;    notecourante:longint;    maxPourBestDef:longint;    aJoue:boolean;     iCourant:longint;     {$IFC not(GENERATING68K) }     indexDansListeChaineeCasesVides:longint;      {$ELSEC}    i,nbVidesTrouvees:longint;    {$ENDC}    label fin;begin  inc(nbreNoeudsGeneresFinale);     adversaire := -couleur;  profMoins1 := pred(ESprof);     maxPourBestDef := -noteMax;  aJoue := false;   {$IFC GENERATING68K}  nbVidesTrouvees := 0;  {$ENDC}    platEssai := plat;  DiffEssai := diffPions;    {$IFC GENERATING68K}    for i := 1 to nbcasesvides do  BEGIN   iCourant := ListeCasesVidesOrdreJCW[i];            if plat[iCourant]=pionVide then       begin        inc(nbVidesTrouvees);         {$ELSEC}     indexDansListeChaineeCasesVides := ListeChaineeCasesVides[k_Head].next;  repeat     with ListeChaineeCasesVides[indexDansListeChaineeCasesVides] do    BEGIN      iCourant := square;      begin        {$ENDC}            if ModifPlatFinDiffFastLongint(iCourant,couleur,adversaire,platEssai,diffEssai) then         BEGIN          aJoue := true;                              {$IFC not(GENERATING68K) }          {EnleverDeLaListeChaineeDesCasesVides(iCourant)}          ListeChaineeCasesVides[previous].next := next;          ListeChaineeCasesVides[next].previous := previous;          {$ENDC}                    if (profMoins1=1)             then                noteCourante := -DernierCoup(platEssai,adversaire,couleur,-diffEssai)            else                noteCourante := -ABFinPetite(platEssai,adversaire,profMoins1,-beta,-alpha,-diffEssai,false);                    {$IFC not(GENERATING68K) }          {RemettreDansLaListeChaineeDesCasesVides(iCourant);}		  ListeChaineeCasesVides[previous].next := indexDansListeChaineeCasesVides;		  ListeChaineeCasesVides[next].previous := indexDansListeChaineeCasesVides;		  {$ENDC}          if (noteCourante>maxPourBestDef) then              begin               maxPourBestDef := noteCourante;               if (noteCourante>alpha) then                  begin                   alpha := noteCourante;                   if (alpha>=beta) then                       begin                        ABFinPetite := maxPourBestDef;                        exit(ABFinPetite);                      end;                 end;             end;                    {$IFC GENERATING68K}          if nbVidesTrouvees>=ESprof then             begin              ABFinPetite := maxPourBestDef;              exit(ABFinPetite);            end;          {$ENDC}                      				  platEssai := plat;          diffEssai := diffPions;                 end                 {$IFC GENERATING68K}        else           if nbVidesTrouvees>=ESprof then goto fin;        {$ENDC}            end;    {$IFC not(GENERATING68K) }    indexDansListeChaineeCasesVides := next;  END;     until indexDansListeChaineeCasesVides = k_NIL;  {$ELSEC}   END;   {$ENDC}fin: if Ajoue   then     begin       ABFinPetite := maxPourBestDef;      end   else     begin       if vientDePasser then         begin           if diffPions>0 then              begin               ABFinPetite := diffPions + ESprof;               exit(ABFinPetite);             end;           if diffPions<0 then              begin               ABFinPetite := diffPions - ESprof;               exit(ABFinPetite);             end;           ABFinPetite := 0;           exit(ABFinPetite);         end                 else         ABFinPetite := -ABFinPetite(plat,adversaire,ESprof,-beta,-alpha,-diffPions,true);     end;end;   { ABFinPetite }  function dernierCoupPourSuite(var plat:plOthEndgame;var meiDef:longint;couleur,adversaire,diffPions:longint):longint;var i,x,t,dx,nbprise,compteur,iCourant:longint;    modifie:boolean;begin   inc(nbreNoeudsGeneresFinale);       for i := 1 to nbcasesvides do    BEGIN    iCourant := casesVides[i];          if plat[iCourant]=pionVide then         begin          {if modifScoreFin(iCourant,couleur,plat,nBla,nNoi) }                modifie := false;nbprise := 0;        for t := dirPrisedeb[iCourant] to dirPriseFin[iCourant] do          begin              dx := dirPrise[t];              x := iCourant+dx;              if plat[x]=adversaire then                begin                  compteur := 0;                  repeat                    inc(compteur);                    x := x+dx;                           until plat[x]<>adversaire;                  if (plat[x]=couleur) then                     begin                        modifie := true;                         nbprise := nbprise+compteur;                     end;                end;           end;        if modifie         then            begin              Meidef := iCourant;              meilleuresuite[1,1] := MeiDef;              dernierCoupPourSuite := succ(diffPions+nbprise+nbprise);              exit(dernierCoupPourSuite);                  end          else            begin              {if modifScoreFin(iCourant,adversaire,plat,nBla,nNoi) }                                            {modifie := false;nbprise := 0;}                   {deja Initialises ci-dessus}                for t := dirPrisedeb[iCourant] to dirPriseFin[iCourant] do                  begin                      dx := dirPrise[t];                      x := iCourant+dx;                      if plat[x]=couleur then                        begin                          compteur := 0;                          repeat                            inc(compteur);                            x := x+dx;                                   until plat[x]<>couleur;                          if (plat[x]=adversaire) then                            begin                               modifie := true;                                nbprise := nbprise+compteur;                            end;                        end;                   end;                              if modifie                 then                  begin                    Meidef := iCourant;                    meilleuresuite[1,1] := MeiDef;                    dernierCoupPourSuite := pred(diffPions-nbprise-nbprise);                    exit(dernierCoupPourSuite);                        end                else                  begin                    Meidef := 44;                    meilleuresuite[1,1] := 0;                    if diffPions>0 then                       begin                        dernierCoupPourSuite := succ(diffPions);                        exit(dernierCoupPourSuite);                      end;                    if diffPions<0 then                       begin                        dernierCoupPourSuite := pred(diffPions);                        exit(dernierCoupPourSuite);                      end;                    dernierCoupPourSuite := 0;                    exit(dernierCoupPourSuite);                  end;            end      end;   END;   dernierCoupPourSuite := diffPions;    {pas de case vide}end;   { dernierCoupPourSuite }function ABFinPetitePourSuite(var plat:plOthEndgame;var Meidef:longint;couleur,ESprof,alpha,beta,diffPions:longint;                              vientDePasser:boolean):longint;{ABFin pour les petites profondeurs ( <= profForceBrute )}var platEssai:plOthEndgame;    diffEssai:longint;    i,k:longint;    adversaire,profMoins1:longint;    notecourante:longint;    maxPourBestDef:longint;    aJoue:boolean;     nbVidesTrouvees:longint;    iCourant:longint;     bestSuite:longint;    label fin;    begin if (interruptionReflexion=pasdinterruption) then    begin    if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);   inc(nbreNoeudsGeneresFinale);      adversaire := -couleur;   profMoins1 := pred(ESprof);      maxPourBestDef := -noteMax;   aJoue := false;    nbVidesTrouvees := 0;      platEssai := plat;   diffEssai := diffPions;      for i := 1 to nbcasesvides do   BEGIN    iCourant := casesVides[i];             if plat[iCourant]=pionVide then         begin        inc(nbVidesTrouvees);        if ModifPlatFinDiffFastLongint(iCourant,couleur,adversaire,platEssai,diffEssai) then          BEGIN           aJoue := true;                      {$IFC not(GENERATING68K) }           EnleverDeLaListeChaineeDesCasesVides(iCourant);           {$ENDC}                      if (profMoins1<=1)              then                 noteCourante := -dernierCoupPourSuite(platEssai,bestSuite,adversaire,couleur,-diffEssai)             else                 noteCourante := -ABFinPetitePourSuite(platEssai,bestSuite,adversaire,profMoins1,                               -beta,-alpha,-diffEssai,false);           {$IFC not(GENERATING68K) }           RemettreDansLaListeChaineeDesCasesVides(iCourant);           {$ENDC}           if (noteCourante>maxPourBestDef) then               begin                                maxPourBestDef := noteCourante;                Meidef := iCourant;                for k := 1 to profMoins1 do                   meilleureSuite[ESprof,k] := meilleureSuite[profMoins1,k];                meilleureSuite[ESprof,ESprof] := Meidef;                                if (noteCourante>alpha) then                   begin                    alpha := noteCourante;                    if (alpha>=beta) then                        begin                         ABFinPetitePourSuite := maxPourBestDef;                         exit(ABFinPetitePourSuite);                       end;                  end;              end;                      if nbVidesTrouvees>=ESprof then              begin               ABFinPetitePourSuite := maxPourBestDef;               exit(ABFinPetitePourSuite);             end;                        platEssai := plat;           diffEssai := diffPions;          END           else            if nbVidesTrouvees>=ESprof then goto fin;       end;   end;        fin:  if Ajoue    then      begin        ABFinPetitePourSuite := maxPourBestDef;       end    else      begin        if vientDePasser then          begin            for k := 1 to ESprof do meilleureSuite[ESprof,k] := 0;            if diffPions>0 then               begin                ABFinPetitePourSuite := diffPions + ESprof;                exit(ABFinPetitePourSuite);              end;            if diffPions<0 then               begin                ABFinPetitePourSuite := diffPions - ESprof;                exit(ABFinPetitePourSuite);              end;            ABFinPetitePourSuite := 0;            exit(ABFinPetitePourSuite);          end                  else          ABFinPetitePourSuite := -ABFinPetitePourSuite(plat,Meidef,adversaire,ESprof,-beta,-alpha,-diffPions,true);      end; end;    {if not(interromp) }end;   { ABFinPetitePourSuite }  function ABFin(var plat:plOthEndgame;var Meidef:longint;pere,couleur,ESprof,alpha,beta,diffPions:longint;               var IndiceHashTableExacteRetour:longint;vientDePasser:boolean;var InfosMilieuDePartie:t_InfosMilieuDePartie):longint;var platEssai:plOthEndgame;    diffEssai:longint;    InfosMilieuEssai:t_InfosMilieuDePartie;    i,k:longint;    adversaire,profMoins1:longint;    notecourante:longint;    maxPourBestDef:longint;    aJoue:boolean;     nbEvalue,nbVidesTrouvees:longint;    iCourant,nbCoupsPourCoul:longint;     bestSuite:longint;    FilsDePere,CaseTestee:longint;    ListeCaseVides,ListeTemp:listeVides;    ListeFinale:listeVides;    DoitChercherindexfilsDePere:boolean;    clefHashConseil,conseilHash:longint;    QuelleHashTableExacte:HashTableExactePtr;    QuelleCoupsLegauxHash:CoupsLegauxHashPtr;    classDiv:array[1..64] of record                       coup:longint;                       mobAdv:longint;                       indexDansKiller:longint;                     end;    indiceHashDesFils:array[1..64] of longint;    valeurExacteMax,valeurExacteMin:longint;    clefHashExacte,nroTableExacte:longint;    CodePosition:record                   platLigne1,platLigne2,platLigne3,platLigne4:longint;                   platLigne5,platLigne6,platLigne7,platLigne8:longint;                 end;    OrdreDuMeilleur:longint;    bas_fenetre,haut_fenetre:longint;    listeFinaleFromScratch:boolean;    valeurMaxParPionsDefinitifs:longint;    valeurMinParPionsDefinitifs:longint;    alphaInitial,betaInitial:longint;        {$IFC not(GENERATING68K) }     indexDansListeChaineeCasesVides:longint;     {$ENDC}    utiliseMilieuDePartie:boolean;    CoupLegal:boolean;  procedure CreeCodePosition;  begin    with CodePosition do      begin        platLigne1 := c1[plat[11]]+c2[plat[12]]+c3[plat[13]]+c4[plat[14]]+                    c5[plat[15]]+c6[plat[16]]+c7[plat[17]]+c8[plat[18]];        platLigne2 := c1[plat[21]]+c2[plat[22]]+c3[plat[23]]+c4[plat[24]]+                    c5[plat[25]]+c6[plat[26]]+c7[plat[27]]+c8[plat[28]];              platLigne3 := c1[plat[31]]+c2[plat[32]]+c3[plat[33]]+c4[plat[34]]+                    c5[plat[35]]+c6[plat[36]]+c7[plat[37]]+c8[plat[38]];        platLigne4 := c1[plat[41]]+c2[plat[42]]+c3[plat[43]]+c4[plat[44]]+                    c5[plat[45]]+c6[plat[46]]+c7[plat[47]]+c8[plat[48]];        platLigne5 := c1[plat[51]]+c2[plat[52]]+c3[plat[53]]+c4[plat[54]]+                    c5[plat[55]]+c6[plat[56]]+c7[plat[57]]+c8[plat[58]];        platLigne6 := c1[plat[61]]+c2[plat[62]]+c3[plat[63]]+c4[plat[64]]+                    c5[plat[65]]+c6[plat[66]]+c7[plat[67]]+c8[plat[68]];        platLigne7 := c1[plat[71]]+c2[plat[72]]+c3[plat[73]]+c4[plat[74]]+                    c5[plat[75]]+c6[plat[76]]+c7[plat[77]]+c8[plat[78]];        platLigne8 := c1[plat[81]]+c2[plat[82]]+c3[plat[83]]+c4[plat[84]]+                    c5[plat[85]]+c6[plat[86]]+c7[plat[87]]+c8[plat[88]];      end;  end;    procedure ExpandHashTableExacte;    begin      with QuelleHashTableExacte^[clefHashExacte],CodePosition do        begin          ligne1 := platLigne1;          ligne2 := platLigne2;          ligne3 := platLigne3;          ligne4 := platLigne4;          ligne5 := platLigne5;          ligne6 := platLigne6;          ligne7 := platLigne7;          ligne8 := platLigne8;          trait := couleur;          ValeurMin := -64;          ValeurMax := 64;          bestDefense := 0;          profondeur := ESprof;          liberee := false;          QuelleCoupsLegauxHash^[clefHashExacte,0] := 0;        end;    end;    procedure MetPosDansHashTableExacte;    begin      with QuelleHashTableExacte^[clefHashExacte],CodePosition do        begin          ligne1 := platLigne1;          ligne2 := platLigne2;          ligne3 := platLigne3;          ligne4 := platLigne4;          ligne5 := platLigne5;          ligne6 := platLigne6;          ligne7 := platLigne7;          ligne8 := platLigne8;          trait := couleur;          profondeur := ESprof;          liberee := false;        end;    end;      procedure AttacheCoupsLegauxDansHash(indexmin,indexmax:longint);  var n:longint;  begin    n := succ(indexmax-indexmin);    if n<=nbMaxCoupsLegauxDansHash      then        begin          QuelleCoupsLegauxHash^[clefHashExacte,0] := n;          for n := indexmin to indexmax do            QuelleCoupsLegauxHash^[clefHashExacte,succ(n-indexmin)] := listeFinale[n].coup;        end      else        QuelleCoupsLegauxHash^[clefHashExacte,0] := 0;  end;    procedure MetCoupEnTeteEtAttacheCoupsLegauxDansHash(indexmin,indexmax,coupAMettreEnTete:longint);  var n,k,coup:longint;  begin    n := succ(indexmax-indexmin);    if n<=nbMaxCoupsLegauxDansHash      then        begin          QuelleCoupsLegauxHash^[clefHashExacte,0] := n;          QuelleCoupsLegauxHash^[clefHashExacte,1] := coupAMettreEnTete;          k := 2;          for n := indexmin to indexmax do            begin              coup := listeFinale[n].coup;              if coup<>coupAMettreEnTete then                begin                  QuelleCoupsLegauxHash^[clefHashExacte,k] := coup;                  inc(k);                end;            end;        end      else        QuelleCoupsLegauxHash^[clefHashExacte,0] := 0;  end;      function PasListeFinaleStockeeDansHash():boolean;  var i,uncoup,n:longint;  begin    n := QuelleCoupsLegauxHash^[clefHashExacte,0];    if (n>0) & (n<=ESprof) then      begin        for i := 1 to n do          begin            uncoup := QuelleCoupsLegauxHash^[clefHashExacte,i];            ListeFinale[i].coup := uncoup;            k := 0;            repeat              inc(k);            until ListeKiller[ESprof,k]=uncoup;            ListeFinale[i].indexDansKiller := k;          end;          nbCoupsPourCoul := n;          PasListeFinaleStockeeDansHash := false;                  end      else        begin          PasListeFinaleStockeeDansHash := true;          QuelleCoupsLegauxHash^[clefHashExacte,0] := 0;        end;  end;      function InfoTrouveeDansHashTableExacte:boolean;  var increment1,increment2,longueurCollisionPath:longint;      clefHashExacteInitiale,clefAEcraser,minProf:longint;  begin    qd.randSeed := ClefHashage+CodePosition.platLigne1+CodePosition.platLigne8+CodePosition.platLigne2+CodePosition.platLigne7;        increment1 := BAND(Random(),1023);    if BAND(increment1,1)=0 then inc(increment1);{pour avoir un nombre premier avec 1024}    clefHashExacte := BAND((clefHashExacte+increment1),1023);    clefHashExacteInitiale := clefHashExacte;        (** on cherche si la position apparait dans la HashTable  **)    longueurCollisionPath := 0;    repeat      with QuelleHashTableExacte^[clefHashExacte],CodePosition do        begin          if trait=0 then             begin              (** une place vide : on peut stopper la recherche **)              InfoTrouveeDansHashTableExacte := false;              exit(InfoTrouveeDansHashTableExacte);            end;          if ligne1=platLigne1 then          if ligne2=platLigne2 then          if ligne3=platLigne3 then          if ligne4=platLigne4 then          if ligne5=platLigne5 then          if ligne6=platLigne6 then          if ligne7=platLigne7 then          if ligne8=platLigne8 then          if trait=couleur then            begin              (** on a trouve la position dans la table **)              InfoTrouveeDansHashTableExacte := true;              liberee := false;              exit(InfoTrouveeDansHashTableExacte);            end;          clefHashExacte := BAND((clefHashExacte+increment1),1023);          inc(longueurCollisionPath);        end;    until (longueurCollisionPath>12);        qd.randSeed := clefHashExacteInitiale+CodePosition.platLigne2+CodePosition.platLigne7;    increment2 := BAND(Random(),1023);    if BAND(increment2,1)=0 then inc(increment2);{pour avoir un nb premier avec 1024}        (** on cherche si la position apparait dans la HashTable  **)    clefHashExacte := clefHashExacteInitiale;    longueurCollisionPath := 0;    repeat      with QuelleHashTableExacte^[clefHashExacte],CodePosition do        begin          if trait=0 then             begin              (** une place vide : on peut stopper la recherche **)              InfoTrouveeDansHashTableExacte := false;              exit(InfoTrouveeDansHashTableExacte);            end;          if ligne1=platLigne1 then          if ligne2=platLigne2 then          if ligne3=platLigne3 then          if ligne4=platLigne4 then          if ligne5=platLigne5 then          if ligne6=platLigne6 then          if ligne7=platLigne7 then          if ligne8=platLigne8 then          if trait=couleur then            begin              (** on a trouve la position dans la table **)              InfoTrouveeDansHashTableExacte := true;              liberee := false;              exit(InfoTrouveeDansHashTableExacte);            end;          clefHashExacte := BAND((clefHashExacte+increment2),1023);          inc(longueurCollisionPath);        end;    until (longueurCollisionPath>12);        InfoTrouveeDansHashTableExacte := false;            (** on cherche une place liberee dans la HashTable **)        clefHashExacte := clefHashExacteInitiale;    longueurCollisionPath := 0;    repeat      if QuelleHashTableExacte^[clefHashExacte].liberee then exit(InfoTrouveeDansHashTableExacte);  (** trouve  **)      clefHashExacte := BAND((clefHashExacte+increment1),1023);      inc(longueurCollisionPath);    until (longueurCollisionPath>12);        clefHashExacte := clefHashExacteInitiale;    longueurCollisionPath := 0;    repeat      if QuelleHashTableExacte^[clefHashExacte].liberee then exit(InfoTrouveeDansHashTableExacte);  (** trouve  **)      clefHashExacte := BAND((clefHashExacte+increment2),1023);      inc(longueurCollisionPath);    until (longueurCollisionPath>12);        (** collision : on ecrase une place le plus bas possible dans l'arbre  **)        minProf := 10000;        clefHashExacte := clefHashExacteInitiale;    longueurCollisionPath := 0;    repeat      if QuelleHashTableExacte^[clefHashExacte].profondeur<minProf then         if QuelleHashTableExacte^[clefHashExacte].profondeur=ProfPourHashExacte          then            exit(InfoTrouveeDansHashTableExacte)  {on ne trouvera pas de profondeur plus basse}          else            begin              clefAEcraser := clefHashExacte;              minProf := QuelleHashTableExacte^[clefHashExacte].profondeur;            end;      clefHashExacte := BAND((clefHashExacte+increment1),1023);      inc(longueurCollisionPath);    until (longueurCollisionPath>12);        clefHashExacte := clefHashExacteInitiale;    longueurCollisionPath := 0;    repeat      if QuelleHashTableExacte^[clefHashExacte].profondeur<minProf then         if QuelleHashTableExacte^[clefHashExacte].profondeur=ProfPourHashExacte          then            exit(InfoTrouveeDansHashTableExacte)  {on ne trouvera pas de profondeur plus basse}          else            begin              clefAEcraser := clefHashExacte;              minProf := QuelleHashTableExacte^[clefHashExacte].profondeur;            end;      clefHashExacte := BAND((clefHashExacte+increment2),1023);      inc(longueurCollisionPath);    until (longueurCollisionPath>12);        {    WriteStringAndNumAt('minProf=',minProf,10,40);    WriteStringAndNumAt('clefAEcraser=',clefAEcraser,10,50);    SysBeep(0);    AttendFrappeClavier;    }        clefHashExacte := clefAEcraser;  (** on ecrase cette position **)  end;    procedure LiberePlacesHashTableExacte(nroPremierFils,nroDernierFils:longint);  var i,t:longint;  begin    for i := nroPremierFils to nroDernierFils do      begin        t := indiceHashDesFils[i];        if t>=0 then          begin            HashTableExacte[t div 1024]^[BAND(t,1023)].liberee := true;            indiceHashDesFils[i] := -3000;          end;      end;  end;      function CaseVideIsolee(CaseVide:longint):boolean;  var t:longint;  begin    for t := DirVoisineDeb[CaseVide] to DirVoisineFin[caseVide] do      if plat[CaseVide+DirVoisine[t]]=pionVide then         begin          CaseVideIsolee := false;          exit(CaseVideIsolee);        end;    CaseVideIsolee := true;  end;   procedure EtablitListeCasesVides;    begin      FilsDePere := fils[pere];      if plat[FilsDePere]<>pionVide        then           begin            nbVidesTrouvees := 0;            i := 0;            repeat              inc(i);              CaseTestee := ListeKiller[ESprof,i];              if plat[CaseTestee]=pionVide then                begin                  inc(nbVidesTrouvees);                  ListeCaseVides[nbVidesTrouvees].coup := CaseTestee;                  ListeCaseVides[nbVidesTrouvees].indexDansKiller := i;                end;            until nbVidesTrouvees>=ESprof;          end        else           begin            ListeCaseVides[1].coup := filsDePere;            DoitChercherindexfilsDePere := true;            nbVidesTrouvees := 1;            i := 0;            repeat              inc(i);              CaseTestee := ListeKiller[ESprof,i];              if plat[CaseTestee]=pionVide then                if CaseTestee=FilsDePere                   then                     begin                      ListeCaseVides[1].indexDansKiller := i;                      DoitChercherindexfilsDePere := false;                    end                  else                    begin                      inc(nbVidesTrouvees);                      ListeCaseVides[nbVidesTrouvees].coup := CaseTestee;                      ListeCaseVides[nbVidesTrouvees].indexDansKiller := i;                    end;            until nbVidesTrouvees>=ESprof;            if DoitChercherindexfilsDePere then              begin                repeat                  inc(i);                until ListeKiller[ESprof,i]=FilsDePere;                ListeCaseVides[1].indexDansKiller := i;              end;          end;      end;          procedure TrierCasesVidesIsolees;  {cases isolées d'abord}   var ii,j,k:longint;   begin     if (plat[conseilHash]=pionVide)       then          begin           j := 1;           k := 0;           for ii := 1 to nbVidesTrouvees do             begin               caseTestee := ListeCaseVides[ii].coup;               if caseTestee=conseilHash                 then                    begin                     ListeFinale[1].coup           := ListeCaseVides[ii].coup;                     ListeFinale[1].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                   end                 else                   if CaseVideIsolee(caseTestee)                     then                       begin                         inc(j);                         ListeFinale[j].coup           := ListeCaseVides[ii].coup;                         ListeFinale[j].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                       end                     else                       begin                         inc(k);                         ListeTemp[k].coup           := ListeCaseVides[ii].coup;                         ListeTemp[k].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                       end;              end;         end       else          begin           j := 0;           k := 0;           for ii := 1 to nbVidesTrouvees do             if CaseVideIsolee(ListeCaseVides[ii].coup)               then                 begin                   inc(j);                   ListeFinale[j].coup           := ListeCaseVides[ii].coup;                   ListeFinale[j].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                 end               else                 begin                   inc(k);                   ListeTemp[k].coup            := ListeCaseVides[ii].coup;                   ListeTemp[k].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                 end;          end;          for ii := 1 to k do       begin         ListeFinale[j+ii].coup           := ListeTemp[ii].coup;         ListeFinale[j+ii].indexDansKiller := ListeTemp[ii].indexDansKiller;       end;   end;      procedure TrierSelonDivergence;  {faible mobilite adverse d'abord}   label finBoucleFor;   var i,j,k,nbCoups,mobAdverse,CoupTest,coupdiv:longint;       x,dx,t,evalAdverse:longint;       platDiv:plOthEndgame;       InfosMilieuDiv:t_InfosMilieuDePartie;       coupLegal:boolean;   begin     platDiv := plat;     if utiliseMilieuDePartie then InfosMilieuDiv := InfosMilieuDePartie;          nbCoups := 0;     for i := 1 to nbVidesTrouvees do       begin         CoupTest := ListeFinale[i].coup;         if utiliseMilieuDePartie            then with InfosMilieuDiv do                  coupLegal := ModifPlatLongint(CoupTest,couleur,platDiv,jouable,nbBlancs,nbNoirs,frontiere)           else   coupLegal := ModifPlatSeulementLongint(CoupTest,couleur,-couleur,platDiv);         if coupLegal           then             begin               inc(nbCoups);               if (CoupTest=conseilHash)                 then                   mobAdverse := -2000000  {comme ca on est sûr de le mettre en tete :-) }                 else                    begin                     mobAdverse := 0;                     for j := 1 to nbVidesTrouvees do                       begin                         coupDiv := ListeCaseVides[j].coup;                         if platDiv[coupDiv]=pionVide then                           begin                             for t := dirPriseDeb[coupDiv] to dirPriseFin[coupDiv] do                               begin                                 dx := dirPrise[t];                                 x := coupDiv+dx;                                 if platDiv[x]=couleur then                                   begin                                     repeat                                       x := x+dx;                                     until platDiv[x]<>couleur;                                     if (platDiv[x] = -couleur) then                                       begin                                         inc(mobAdverse);                                         if estUnCoin[coupDiv] then inc(mobAdverse); {les coins comptent pour deux}                                         goto finBoucleFor;                                       end;                                   end;                               end;                             finBoucleFor:                           end;                       end;                                          if utiliseMilieuDePartie then                       with InfosMilieuDiv do                         begin                                                    {                           evalAdverse := Evaluation(platDiv,-couleur,nbBlancs,nbNoirs,jouable,frontiere,false,-30000,30000,bidlong);                           }                                                                           if not(using48AmeliorationsInCoupGagnantOld) | (profTriInterneEnFinale[64-nbBlancs-nbNoirs]<0)                             then                                evalAdverse := Evaluation(platDiv,-couleur,nbBlancs,nbNoirs,jouable,frontiere,false,-30000,30000,bidlong)                             else                                evalAdverse := AB_simple(platDiv,jouable,bidint,-couleur,profTriInterneEnFinale[64-nbBlancs-nbNoirs],                                                         -30000,30000,nbBlancs,nbNoirs,frontiere,false);                                                                                                            if utilisationNouvelleEval                             then                                begin                                 if evalAdverse <= (-beta*100-200)                                    then                                     begin                                       {	                                     WritelnPositionEtTraitDansRapport(plat,couleur);	                                     WritelnStringDansRapport('coup critique='+CoupEnString(CoupTest,true));	                                     WritelnStringAndNumDansRapport('evalAdverse=',evalAdverse);	                                     WritelnStringAndNumDansRapport('avant, mobAdverse=',mobAdverse);	                                     }	                                     mobAdverse := mobAdverse*10000;	                                     mobAdverse := mobAdverse+evalAdverse;	                                     mobAdverse := mobAdverse-1000000;                                       {                                       WritelnStringAndNumDansRapport('après, mobAdverse=',mobAdverse);                                       WritelnDansRapport('');	                                     AttendFrappeClavier;                                       }                                     end                                   else                                     begin                                                       mobAdverse := mobAdverse+(evalAdverse div 200);                                     end;                                                                end                             else mobAdverse := mobAdverse+(evalAdverse div 1000);                         end;                   end;                                  {la phase d'insertion du tri par insertion selon la mobilite adverse decroissante}               k := 1;               while (ClassDiv[k].mobAdv<=mobAdverse) & (k<nbCoups) do inc(k);               for j := nbCoups downto succ(k) do ClassDiv[j].coup := ClassDiv[pred(j)].coup;               for j := nbCoups downto succ(k) do ClassDiv[j].mobAdv := ClassDiv[pred(j)].mobAdv;               for j := nbCoups downto succ(k) do ClassDiv[j].indexDansKiller := ClassDiv[pred(j)].indexDansKiller;               ClassDiv[k].coup := CoupTest;               ClassDiv[k].mobAdv := mobAdverse;               ClassDiv[k].indexDansKiller := ListeFinale[i].indexDansKiller;                 platDiv := plat;               if utiliseMilieuDePartie then InfosMilieuDiv := InfosMilieuDePartie;             end;       end;        for i := 1 to nbCoups do       begin         listeFinale[i].coup := ClassDiv[i].coup;         listeFinale[i].indexDansKiller := ClassDiv[i].indexDansKiller;       end;     nbCoupsPourCoul := nbCoups;   end;    procedure AfficheResultatsPremiersNiveaux(couleurAffichee:longint;nro,total:longint);  var typeAffichage,noteAffichee,noteDeTeteVisible:longint;      pourcentageDejaVisible,pourcentageAffiche:longint;      pourcentagePartielProf2:longint;      profDansArbre:longint;  begin      if analyseRetrograde.enCours & passeDeRechercheAuMoinsNulle & (ReflexData^.class[1].note<0)      then noteDeTeteVisible := -1      else noteDeTeteVisible := ReflexData^.class[1].note;      pourcentageDejaVisible := ReflexData^.class[indexDuCoupDansFntrReflexion].pourcentageCertitude;    if total>0       then pourcentageAffiche := Round(100.0*nro/(1.0*total) - 0.01)       else pourcentageAffiche := 100;      profDansArbre := nbCasesVides-ESprof;    with InfosPourcentagesCertitudesAffiches[profDansArbre] do      begin        mobiliteCetteProf := total;        indexDuCoupCetteProf := nro;        PourcentageAfficheCetteProf := pourcentageAffiche;      end;              if profDansArbre<>2       then pourcentagePartielProf2 := pourcentageAffiche      else with InfosPourcentagesCertitudesAffiches[1] do        begin          pourcentagePartielProf2 := Round(100.0*(indexDuCoupCetteProf - 1 + nro/total)/mobiliteCetteProf -0.01);          end;            if (Esprof<=nbcasesVides-2) &       not(passeDeRechercheAuMoinsNulle) &       (maxPourBestDef>noteDeTeteVisible) &       (pourcentagePartielProf2>pourcentageAffiche)        then pourcentageAffiche := pourcentagePartielProf2;         if (Esprof<=nbcasesVides-2) &       passeDeRechercheAuMoinsNulle &       (maxPourBestDef=0)       then pourcentageAffiche := pourcentagePartielProf2;      if (nro=1) & (total>1) & (indexDuCoupDansFntrReflexion>1) &      not(FenetreLargePourRechercheScoreExact) then      exit(afficheResultatsPremiersNiveaux);        {    if (Esprof<=nbcasesVides-2) &       not(passeDeRechercheAuMoinsNulle) &       (maxPourBestDef>noteDeTeteVisible+2) &       (nro>1) & (total>1)     then       begin         	EssaieSetPortWindowPlateau;			    EcritPositionAt(plat,10,10);			     WriteStringAndNumAt(' prof=',ESprof,10,130);			     WriteStringAndNumAt(' nbcasesVides=',nbcasesVides,80,130);			     if couleur=PionBlanc			       then WriteStringAt('PionBlanc  ',210,130)			       else WriteStringAt('PionNoir    ',210,130);			     WriteStringAndNumAt('nro=',nro,10,140);			     WriteStringAndNumAt('total=',total,70,140);			     WriteStringAndNumAt('certitude=',pourcentageAffiche,150,140);			     WriteStringAndNumAt('pourcentagePartiel=',pourcentagePartielProf2,240,140);			     WriteStringAt('pere='+CoupEnStringEnMajuscules(pere),70,150);			     WriteStringAndNumAt('note=',maxPourBestDef,200,150);			     			     WriteStringAt('meiDef='+CoupEnStringEnMajuscules(meiDef),70,160);			     WriteStringAndNumAt('maxPourBestDef=',maxPourBestDef,200,160);			     WriteStringAndNumAt('alpha=',alpha,10,170);			     WriteStringAndNumAt('beta=',beta,90,170);			     WriteStringAndNumAt('alphaInitial=',alphaInitial,10,180);			     WriteStringAndNumAt('betaInitial=',betaInitial,90,180);			     			     WriteStringAndNumAt('coul=',couleurAffichee,150,170);			     WriteStringAndNumAt('coulDef=',CoulDefense,220,170);			     SysBeep(0);			     AttendFrappeClavier;       end;    }        if (Esprof<=nbcasesVides-2) &        passeDeRechercheAuMoinsNulle &       (maxPourBestDef=0) &       (nro<=1) & (total>1) then       exit(afficheResultatsPremiersNiveaux);         {    if (Esprof<=nbcasesVides-2) &       not(passeDeRechercheAuMoinsNulle) &       (indexDuCoupDansFntrReflexion<=1) then       exit(afficheResultatsPremiersNiveaux);     }           if (Esprof<=nbcasesVides-2) &       (couleurAffichee=CoulDefense) then       exit(afficheResultatsPremiersNiveaux);               if (Esprof<=nbcasesVides-2) &       not(passeDeRechercheAuMoinsNulle) &       (maxPourBestDef>noteDeTeteVisible+2) &       (indexDuCoupDansFntrReflexion>1) &       (nro=1) & (total>1)      then exit(afficheResultatsPremiersNiveaux);            if (Esprof<=nbcasesVides-2) &       (pourcentageDejaVisible>0) &       (pourcentageDejaVisible<100) &       (pourcentageAffiche<pourcentageDejaVisible) then       exit(afficheResultatsPremiersNiveaux);                 if not(bestMode)      then         if analyseRetrograde.enCours          then            typeAffichage := ReflRetrogradeGagnant          else            if typeCalculFinale=ReflPseudo              then typeAffichage := ReflPseudo              else typeAffichage := ReflGagnant      else        if analyseRetrograde.enCours          then             if FenetreLargePourRechercheScoreExact               then typeAffichage := ReflRetrogradeParfaitPhaseRechScore              else if passeDeRechercheAuMoinsNulle                     then typeAffichage := ReflRetrogradeParfaitPhaseGagnant                     else typeAffichage := ReflRetrogradeParfait          else             if FenetreLargePourRechercheScoreExact               then typeAffichage := ReflParfaitPhaseRechScore              else if passeDeRechercheAuMoinsNulle                     then typeAffichage := ReflParfaitPhaseGagnant                     else typeAffichage := ReflParfait;                          noteAffichee := -maxPourBestDef;     if (noteAffichee>0) & passeDeRechercheAuMoinsNulle then noteAffichee := +1;     if (noteAffichee=0) & passeDeRechercheAuMoinsNulle then noteAffichee := 0;     if (noteAffichee<0) & passeDeRechercheAuMoinsNulle then noteAffichee := -1;     if couleurAffichee<>CoulDefense then noteAffichee := -noteAffichee;          if (Esprof<=nbcasesVides-2) &         (not(passeDeRechercheAuMoinsNulle) | (maxPourBestDef=0)) &        ((maxPourBestDef>noteDeTeteVisible+2) | (indexDuCoupDansFntrReflexion=1))      then pourcentageAffiche := pourcentagePartielProf2;          ReflexData^.typeDonnees := typeAffichage;     ReflexData^.compteur := indexDuCoupDansFntrReflexion;     ReflexData^.IndexCoupEnCours := indexDuCoupDansFntrReflexion;     with ReflexData^.class[indexDuCoupDansFntrReflexion] do       begin         note := noteAffichee;         if (Esprof<=nbcasesVides-2)           then def := pere           else def := meiDef;         pourcentageCertitude := pourcentageAffiche;         delta := kDeltaFinaleInfini;         temps := (TickCount()-tickChrono);       end;     if affichageReflexion.doitAfficher then EcritReflexion;                     {    EssaieSetPortWindowPlateau;    EcritPositionAt(plat,10,10);    EcritPositionAt(position,200,10);     WriteStringAndNumAt(' prof=',ESprof,10,130);     WriteStringAndNumAt(' nbcasesVides=',nbcasesVides,80,130);     if couleur=PionBlanc       then WriteStringAt('PionBlanc  ',210,130)       else WriteStringAt('PionNoir    ',210,130);     WriteStringAndNumAt('nro=',nro,10,140);     WriteStringAndNumAt('total=',total,70,140);     WriteStringAndNumAt('certitude=',Round(0.4+100.0*nro/(1.0*total)),150,140);     WriteStringAt('coup='+CoupEnStringEnMajuscules(coup),70,150);     WriteStringAndNumAt('note=',note,200,150);     WriteStringAt('meiDef='+CoupEnStringEnMajuscules(meiDef),70,160);     WriteStringAndNumAt('maxPourBestDef=',maxPourBestDef,200,160);     SysBeep(0);     AttendFrappeClavier;     }  end;    begin if (interruptionReflexion=pasdinterruption) then    begin   if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);   inc(nbreNoeudsGeneresFinale);   listeFinaleFromScratch := true;   maxPourBestDef := -noteMax;   OrdreDuMeilleur := -1;   meidef := -1;   utiliseMilieuDePartie := (ESProf>=profMinimalePourClassementParMilieu) & (alpha<40) & (beta>-40);      valeurExacteMax := notemax;   valeurExacteMin := -notemax;   if ESprof>=ProfUtilisationHash     then        begin         ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);         if ESprof>=profondeurRemplissageHash            then              begin               clefHashConseil := BAND(ClefHashage,32767);               conseilHash := HashTable^^[clefHashConseil];             end           else conseilHash := 0;                  if ESprof>=ProfPourHashExacte then            begin                        nroTableExacte := BAND(ClefHashage div 1024,nbTablesHashExactesMoins1);             clefHashExacte := BAND(ClefHashage,1023);             QuelleHashTableExacte := HashTableExacte[nroTableExacte];             QuelleCoupsLegauxHash := CoupsLegauxHash[nroTableExacte];             CreeCodePosition;             if InfoTrouveeDansHashTableExacte               then                  begin                   with QuelleHashTableExacte^[clefHashExacte] do                     begin                       meiDef := bestdefense;                       if bestMode                          then                           begin                             if ValeurMin>alpha then alpha := pred(ValeurMin);                             if ValeurMax<beta then beta := succ(ValeurMax);                           end                         else                           begin                             if ValeurMin>alpha then alpha := ValeurMin;                             if ValeurMax<beta then beta := ValeurMax;                           end;                       if ValeurMin>=ValeurMax                          then                                 begin                                              if bestMode & (alpha<=ValeurMax) & (ValeurMin<=beta)                               then                                 begin                                                                  QuelleCoupsLegauxHash^[clefHashExacte,0] := 1;                                   QuelleCoupsLegauxHash^[clefHashExacte,1] := meiDef;                                 end                               else                                 begin                                   ABFin := ValeurMin;                                   if ESprof>=profondeurRemplissageHash then                                     HashTable^^[clefHashConseil] := MeiDef;                                   ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);                                   exit(ABFin);                                 end;                           end                         else                           begin                             if ValeurMin>=beta then                                begin                                 ABFin := ValeurMin;                                 if ESprof>=profondeurRemplissageHash then                                   HashTable^^[clefHashConseil] := MeiDef;                                 ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);                                 exit(ABFin);                               end;                             if ValeurMax<=alpha then                               begin                                 ABFin := ValeurMax;                                 if ESprof>=profondeurRemplissageHash then                                   HashTable^^[clefHashConseil] := MeiDef;                                 ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);                                 exit(ABFin);                               end;                           end;                     end;                   listeFinaleFromScratch := PasListeFinaleStockeeDansHash();                   valeurExacteMax := QuelleHashTableExacte^[clefHashExacte].ValeurMax;                   valeurExacteMin := QuelleHashTableExacte^[clefHashExacte].ValeurMin;                 end               else                  begin                   ExpandHashTableExacte;                   valeurExacteMax := QuelleHashTableExacte^[clefHashExacte].ValeurMax;                   valeurExacteMin := QuelleHashTableExacte^[clefHashExacte].ValeurMin;                 end;             IndiceHashTableExacteRetour := clefHashExacte+1024*nroTableExacte;           end;       end     else        conseilHash := 0;      adversaire := -couleur;   profMoins1 := pred(ESprof);      if alpha>=40 then      begin       if alpha>=50         then valeurMaxParPionsDefinitifs := 64-2*nbPionsDefinitifsAvecInterieursEndgame(adversaire,plat)         else valeurMaxParPionsDefinitifs := 64-2*nbPionsDefinitifsEndgame(adversaire,plat);       if valeurMaxParPionsDefinitifs < beta then beta := succ(valeurMaxParPionsDefinitifs);       {if valeurMaxParPionsDefinitifs < beta then beta := valeurMaxParPionsDefinitifs;}       if valeurMaxParPionsDefinitifs <= alpha then          begin           if ESprof>=ProfUtilisationHash then             begin               if ESprof>=profondeurRemplissageHash                  then HashTable^^[clefHashConseil] := MeiDef;               ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);             end;           ABFin := valeurMaxParPionsDefinitifs;           exit(ABFin);         end;     end;   if (beta<=-40) & (profMoins1<=profForceBrute) then      begin       if beta<=-50         then valeurMinParPionsDefinitifs := -64+2*nbPionsDefinitifsAvecInterieursEndgame(couleur,plat)         else valeurMinParPionsDefinitifs := -64+2*nbPionsDefinitifsEndgame(couleur,plat);       if valeurMinParPionsDefinitifs > alpha then alpha := pred(valeurMinParPionsDefinitifs);       {if valeurMinParPionsDefinitifs > alpha then alpha := valeurMinParPionsDefinitifs;}       if valeurMinParPionsDefinitifs >= beta then          begin           if ESprof>=ProfUtilisationHash then             begin               if ESprof>=profondeurRemplissageHash                  then HashTable^^[clefHashConseil] := MeiDef;               ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);             end;           ABFin := valeurMinParPionsDefinitifs;           exit(ABFin);         end;     end;      if listeFinaleFromScratch then      begin       EtablitListeCasesVides;       TrierCasesVidesIsolees;       nbCoupsPourCoul := nbVidesTrouvees;       if ESprof>=profTriSelonDivergence then TrierSelonDivergence;              if nbCoupsPourCoul>nbMaxCoupsEnvisages[ESProf] then         nbCoupsPourCoul := nbMaxCoupsEnvisages[ESProf];              (*       if Esprof>=ProfPourHashExacte then           AttacheCoupsLegauxDansHash(1,nbCoupsPourCoul);       *)     end;            aJoue := false;   nbEvalue := 0;      platEssai := plat;   diffEssai := diffPions;   if utiliseMilieuDePartie then InfosMilieuEssai := InfosMilieuDePartie;       alphaInitial := alpha;   betaInitial := beta;      for i := 1 to nbCoupsPourCoul do    begin     indiceHashDesFils[i] := -3000;          if maxPourBestDef<valeurExacteMax then        with ListeFinale[i] do         BEGIN          iCourant := coup;                    (*** pour debugage seulement ***)          {if iCourant<11 then debugger else          if iCourant>88 then debugger else          if platEssai[iCourant]<>pionVide then debugger;          }                    if utiliseMilieuDePartie            then               begin                with InfosMilieuEssai do                  begin                    coupLegal := ModifPlatLongint(iCourant,couleur,platEssai,jouable,nbBlancs,nbNoirs,frontiere);                    if coupLegal then                      if couleur=PionNoir                        then diffEssai := nbNoirs-nbBlancs                        else diffEssai := nbBlancs-nbNoirs;                  end;              end            else               coupLegal := ModifPlatFinDiffFastLongint(iCourant,couleur,adversaire,platEssai,diffEssai);                    if coupLegal then             begin             aJoue := true;             (*tickPourEstimerTempsPris := TickCount();*)                          {$IFC not(GENERATING68K) }             {EnleverDeLaListeChaineeDesCasesVides(iCourant)}             indexDansListeChaineeCasesVides := tableDesPointeurs[iCourant];             with ListeChaineeCasesVides[indexDansListeChaineeCasesVides] do	            begin	              ListeChaineeCasesVides[previous].next := next;	              ListeChaineeCasesVides[next].previous := previous;	            end;             {$ENDC}                          if ESprof>=nbcasesVides-2 then               begin                  with InfosPourcentagesCertitudesAffiches[nbCasesVides-ESprof] do					          begin					            mobiliteCetteProf := nbCoupsPourCoul;					            indexDuCoupCetteProf := i;				            end;               end;                                       if (profMoins1<=profForceBrute)                then                   noteCourante := -ABFinPetite(platEssai,adversaire,profMoins1,-beta,-alpha,-diffEssai,false)               else                  begin                   if (nbEvalue<=0)                    then                       begin                       noteCourante := -ABFin(platEssai,bestSuite,iCourant,adversaire,profMoins1,                                      -beta,-alpha,-diffEssai,indiceHashDesFils[i],false,InfosMilieuEssai);                       nbEvalue := 1;                      end                    else                     begin                       noteCourante := -ABFin(platEssai,bestSuite,iCourant,adversaire,profMoins1,                                      pred(-alpha),-alpha,-diffEssai,indiceHashDesFils[i],false,InfosMilieuEssai);                       if (alpha<noteCourante) & (noteCourante<beta) then                         if bestMode                           then                             repeat                               bas_fenetre := pred(noteCourante);                               haut_fenetre := bas_fenetre+8;                               if haut_fenetre>beta then haut_fenetre := beta;                               noteCourante := -ABFin(platEssai,bestSuite,iCourant,adversaire,profMoins1,                                                   -haut_fenetre,-bas_fenetre,-diffEssai,indiceHashDesFils[i],false,InfosMilieuEssai)                             until ((bas_fenetre<noteCourante) & (noteCourante<haut_fenetre)) |                                    (noteCourante>=beta) | (interruptionReflexion<>pasdinterruption)                           else                              noteCourante := -ABFin(platEssai,bestSuite,iCourant,adversaire,profMoins1,                                                -beta,-noteCourante,-diffEssai,indiceHashDesFils[i],false,InfosMilieuEssai);                     end;                  end;                              {$IFC not(GENERATING68K) }               {RemettreDansLaListeChaineeDesCasesVides(iCourant);}						   with ListeChaineeCasesVides[indexDansListeChaineeCasesVides] do							 begin							   ListeChaineeCasesVides[previous].next := indexDansListeChaineeCasesVides;							   ListeChaineeCasesVides[next].previous := indexDansListeChaineeCasesVides;							 end;						   {$ENDC}                             if (noteCourante>maxPourBestDef) then                  begin                   maxPourBestDef := noteCourante;                   Meidef := iCourant;                                      if (noteCourante>alpha) then                      begin                       alpha := noteCourante;                       OrdreDuMeilleur := i;                       if (ESprof>=ProfPourHashExacte) then                         begin                           valeurExacteMin := maxPourBestDef;                           MetPosDansHashTableExacte;                           if ESprof>ProfPourHashExacte then                              if i>1 then LiberePlacesHashTableExacte(1,pred(i));                                                      if using48AmeliorationsInCoupGagnantOld                             then MetCoupEnTeteEtAttacheCoupsLegauxDansHash(i,nbCoupsPourCoul,iCourant)                             else AttacheCoupsLegauxDansHash(i,nbCoupsPourCoul);                                                      with QuelleHashTableExacte^[clefHashExacte] do                             begin                               ValeurMax := valeurExacteMax;                               ValeurMin := maxPourBestDef;                               bestDefense := meiDef;                             end;                         end;                                              if (alpha>=beta) then                           begin                            ABFin := maxPourBestDef;                                                                                    if noteCourante=64 then                              begin                                for k := profForceBrutePlusUn to profMoins1 do                                  meilleureSuite[ESprof,k] := meilleureSuite[profMoins1,k];                                meilleureSuite[ESprof,ESprof] := Meidef;                              end;                                                        if (indexDansKiller>nbCoinsVidesPlus1) then                              begin                                for k := indexDansKiller downto nbCoinsVidesPlus2 do                                    ListeKiller[ESprof,k] := ListeKiller[ESprof,pred(k)];                                ListeKiller[ESprof,nbCoinsVidesPlus1] := iCourant;                              end;                                                        if ESprof>=ProfUtilisationHash then                              begin                                if ESprof>=profondeurRemplissageHash                                   then HashTable^^[clefHashConseil] := MeiDef;                                ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);                              end;                                                          fils[pere] := iCourant;                            exit(ABFin)                          end;                     end;                                                         for k := profForceBrutePlusUn to profMoins1 do                     meilleureSuite[ESprof,k] := meilleureSuite[profMoins1,k];                   meilleureSuite[ESprof,ESprof] := Meidef;                                                       end;                           if ESprof>=nbcasesVides-2 then               AfficheResultatsPremiersNiveaux(couleur,i,nbCoupsPourCoul);                              platEssai := plat;             diffEssai := diffPions;             if utiliseMilieuDePartie then InfosMilieuEssai := InfosMilieuDePartie;                         end;          END;     end;      if Ajoue    then       begin           if ESprof>=ProfUtilisationHash then          begin            if ESprof>=profondeurRemplissageHash then              HashTable^^[clefHashConseil] := MeiDef;            ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);                        if ESprof>=ProfPourHashExacte then                begin                  MetPosDansHashTableExacte;                  if ordreDuMeilleur>=1                       then                  { alpha < maxPourBestDef < beta }                      begin                        if ESprof>ProfPourHashExacte then                           begin                            if ordreDuMeilleur>1 then                               LiberePlacesHashTableExacte(1,pred(ordreDuMeilleur));                            if ordreDuMeilleur<nbCoupsPourCoul then                               LiberePlacesHashTableExacte(succ(ordreDuMeilleur),nbCoupsPourCoul);                          end;                        AttacheCoupsLegauxDansHash(ordreDuMeilleur,ordreDuMeilleur);                      end                    else                  { maxPourBestDef <= alpha }                      begin                        (*TrieEtAttacheCoupsLegauxDansHash(1,nbCoupsPourCoul);*)                        AttacheCoupsLegauxDansHash(1,nbCoupsPourCoul);                      end;                  with QuelleHashTableExacte^[clefHashExacte] do                    begin                      ValeurMax := maxPourBestDef;                      ValeurMin := valeurExacteMin;                      bestDefense := meiDef;                    end;                end;          end;                ABFin := maxPourBestDef;      end    else       begin        if ESprof>=ProfUtilisationHash then          ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);                  if vientDePasser          then            begin              if diffPions>0 then ABFin := diffPions + ESprof else              if diffPions<0 then ABFin := diffPions - ESprof else                ABFin := 0;              for k := profForceBrutePlusUn to ESprof do meilleureSuite[ESprof,k] := 0;            end                    else            ABFin := -ABFin(plat,Meidef,pere,adversaire,ESprof,-beta,-alpha,-diffPions,IndiceHashTableExacteRetour,true,InfosMilieuDePartie);      end;  end;end;   { ABFin }function LanceurABFin(var plat:plOth;var Meidef:longint;pere,couleur,ESprof,alpha,beta,nbBlancs,nbNoirs:longint;               var IndiceHashTableExacteRetour:longint;var InfosMilieuDePartie:t_InfosMilieuDePartie):longint;var platEndgame:plOthEndgame;begin  copyEnPlOthEndgame(plat,platEndgame);  if couleur=pionNoir    then LanceurABFin := ABFin(platEndgame,Meidef,pere,couleur,ESprof,alpha,beta,nbNoirs-nbBlancs,IndiceHashTableExacteRetour,false,InfosMilieuDePartie)    else LanceurABFin := ABFin(platEndgame,Meidef,pere,couleur,ESprof,alpha,beta,nbBlancs-nbNoirs,IndiceHashTableExacteRetour,false,InfosMilieuDePartie);end;function ABPreOrdre(var plat:plOth;var joua:plBool;var Meidef:longint;                 pere,couleur,ESprof,alpha,beta,nBla,nNoi:longint;var fr:InfoFrontRec):longint;var platEssai:plOth;    jouablEssai:plBool;    nbBlcEssai,nbNrEssai:longint;    frontEssai:InfoFrontRec;    i,k:longint;    adversaire,profMoins1:longint;    notecourante,nbCoupsPourCoul:longint;    maxPourBestDef:longint;    aJoue:boolean;     nbEvalue:longint;    iCourant,conseilHash:longint;    clefHashConseil:longint;    caseCritiqueTurbulence:longint;    bestSuite,nbVidesTrouvees:longint;    FilsDePere,CaseTestee:longint;    ListeCaseVides,ListeTemp:listeVides;    ListeFinale:listeVides;    classDiv:array[1..64] of record                               coup:longint;                               mobAdv:longint;                               indexDansKiller:longint;                             end;    DoitChercherindexfilsDePere:boolean;    evaluerMaintenant:boolean;    DoitRemplirTableHashSimple:boolean;    QuelleHashTableExacte:HashTableExactePtr;    clefHashExacte:longint;    CodePosition:record                   platLigne1,platLigne2,platLigne3,platLigne4:longint;                   platLigne5,platLigne6,platLigne7,platLigne8:longint;                 end;    procedure CreeCodePosition;  begin    with CodePosition do      begin        platLigne1 := c1[plat[11]]+c2[plat[12]]+c3[plat[13]]+c4[plat[14]]+                    c5[plat[15]]+c6[plat[16]]+c7[plat[17]]+c8[plat[18]];        platLigne2 := c1[plat[21]]+c2[plat[22]]+c3[plat[23]]+c4[plat[24]]+                    c5[plat[25]]+c6[plat[26]]+c7[plat[27]]+c8[plat[28]];              platLigne3 := c1[plat[31]]+c2[plat[32]]+c3[plat[33]]+c4[plat[34]]+                    c5[plat[35]]+c6[plat[36]]+c7[plat[37]]+c8[plat[38]];        platLigne4 := c1[plat[41]]+c2[plat[42]]+c3[plat[43]]+c4[plat[44]]+                    c5[plat[45]]+c6[plat[46]]+c7[plat[47]]+c8[plat[48]];        platLigne5 := c1[plat[51]]+c2[plat[52]]+c3[plat[53]]+c4[plat[54]]+                    c5[plat[55]]+c6[plat[56]]+c7[plat[57]]+c8[plat[58]];        platLigne6 := c1[plat[61]]+c2[plat[62]]+c3[plat[63]]+c4[plat[64]]+                    c5[plat[65]]+c6[plat[66]]+c7[plat[67]]+c8[plat[68]];        platLigne7 := c1[plat[71]]+c2[plat[72]]+c3[plat[73]]+c4[plat[74]]+                    c5[plat[75]]+c6[plat[76]]+c7[plat[77]]+c8[plat[78]];        platLigne8 := c1[plat[81]]+c2[plat[82]]+c3[plat[83]]+c4[plat[84]]+                    c5[plat[85]]+c6[plat[86]]+c7[plat[87]]+c8[plat[88]];      end;  end;  function PositionEstDansHashTableExacte:boolean;  var increment1,increment2,longueurCollisionPath:longint;      clefHashExacteInitiale:longint;  begin    qd.randSeed := ClefHashage+CodePosition.platLigne1+CodePosition.platLigne8+CodePosition.platLigne2+CodePosition.platLigne7;    increment1 := BAND(Random(),1023);    if BAND(increment1 , 1)=0 then inc(increment1);{pour avoir un nombre premier avec 1024}    clefHashExacte := BAND((clefHashExacte+increment1) , 1023);    clefHashExacteInitiale := clefHashExacte;        (** on cherche si la position apparait dans la HashTable  **)    longueurCollisionPath := 0;    repeat      with QuelleHashTableExacte^[clefHashExacte],CodePosition do        begin          if trait=0 then  (** une place vide : on peut stopper la recherche infructueusement**)            begin              PositionEstDansHashTableExacte := false;              exit(PositionEstDansHashTableExacte);            end;          if ligne1=platLigne1 then          if ligne2=platLigne2 then          if ligne3=platLigne3 then          if ligne4=platLigne4 then          if ligne5=platLigne5 then          if ligne6=platLigne6 then          if ligne7=platLigne7 then          if ligne8=platLigne8 then          if trait=couleur then (** on a trouve la position dans la table **)            begin              PositionEstDansHashTableExacte := true;              exit(PositionEstDansHashTableExacte);            end;          clefHashExacte := BAND((clefHashExacte+increment1) , 1023);          inc(longueurCollisionPath);        end;    until (longueurCollisionPath>12);        qd.randSeed := clefHashExacteInitiale+CodePosition.platLigne2+CodePosition.platLigne7;    increment2 := BAND(Random(),1023);    if BAND(increment2 , 1)=0 then inc(increment2);{pour avoir un nb premier avec 1024}        (** on cherche si la position apparait dans la HashTable  **)    clefHashExacte := clefHashExacteInitiale;    longueurCollisionPath := 0;    repeat      with QuelleHashTableExacte^[clefHashExacte],CodePosition do        begin          if trait=0 then   (** une place vide : on peut stopper la recherche infructueusement**)            begin              PositionEstDansHashTableExacte := false;              exit(PositionEstDansHashTableExacte);            end;          if ligne1=platLigne1 then          if ligne2=platLigne2 then          if ligne3=platLigne3 then          if ligne4=platLigne4 then          if ligne5=platLigne5 then          if ligne6=platLigne6 then          if ligne7=platLigne7 then          if ligne8=platLigne8 then          if trait=couleur then  (** on a trouve la position dans la table **)            begin              PositionEstDansHashTableExacte := true;              exit(PositionEstDansHashTableExacte);            end;          clefHashExacte := BAND((clefHashExacte+increment2) , 1023);          inc(longueurCollisionPath);        end;    until (longueurCollisionPath>12);        PositionEstDansHashTableExacte := false;      end;      function CaseVideIsolee(CaseVide:longint):boolean;  var t:longint;  begin    for t := DirVoisineDeb[CaseVide] to DirVoisineFin[caseVide] do      if plat[CaseVide+DirVoisine[t]]=pionVide then         begin          CaseVideIsolee := false;          exit(CaseVideIsolee);        end;    CaseVideIsolee := true;  end;   procedure EtablitListeCasesVides;    begin      FilsDePere := fils[pere];      if plat[FilsDePere]<>pionVide        then           begin            nbVidesTrouvees := 0;            i := 0;            repeat              inc(i);              CaseTestee := ListeKiller[ESprof,i];                            (*** pour debugage seulement ***)              {if CaseTestee<11 then debugger else              if CaseTestee>88 then debugger;}                            if plat[CaseTestee]=pionVide then                begin                  inc(nbVidesTrouvees);                  ListeCaseVides[nbVidesTrouvees].coup := CaseTestee;                  ListeCaseVides[nbVidesTrouvees].indexDansKiller := i;                end;            until nbVidesTrouvees>=ESprof;          end        else           begin            ListeCaseVides[1].coup := filsDePere;            DoitChercherindexfilsDePere := true;            nbVidesTrouvees := 1;            i := 0;            repeat              inc(i);              CaseTestee := ListeKiller[ESprof,i];                            (*** pour debugage seulement ***)              {if CaseTestee<11 then debugger else              if CaseTestee>88 then debugger;}                                          if plat[CaseTestee]=pionVide then                if CaseTestee=FilsDePere                   then                     begin                      ListeCaseVides[1].indexDansKiller := i;                      DoitChercherindexfilsDePere := false;                    end                  else                    begin                      inc(nbVidesTrouvees);                      ListeCaseVides[nbVidesTrouvees].coup := CaseTestee;                      ListeCaseVides[nbVidesTrouvees].indexDansKiller := i;                    end;            until nbVidesTrouvees>=ESprof;            if DoitChercherindexfilsDePere then              begin                repeat                  inc(i);                until ListeKiller[ESprof,i]=FilsDePere;                ListeCaseVides[1].indexDansKiller := i;              end;          end;      end;       {cases isolées d'abord}   procedure TrierCasesVidesIsolees;   var ii,j,k:longint;   begin     if plat[conseilHash]=pionVide        then          begin           j := 1;           k := 0;           for ii := 1 to nbVidesTrouvees do             begin               caseTestee := ListeCaseVides[ii].coup;               if caseTestee=conseilHash                 then                    begin                     ListeFinale[1].coup           := ListeCaseVides[ii].coup;                     ListeFinale[1].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                   end                 else                   if CaseVideIsolee(caseTestee)                     then                       begin                         inc(j);                         ListeFinale[j].coup           := ListeCaseVides[ii].coup;                         ListeFinale[j].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                       end                     else                       begin                         inc(k);                         ListeTemp[k].coup           := ListeCaseVides[ii].coup;                         ListeTemp[k].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                       end;              end;         end       else          begin           j := 0;           k := 0;           for ii := 1 to nbVidesTrouvees do             if CaseVideIsolee(ListeCaseVides[ii].coup)               then                 begin                   inc(j);                   ListeFinale[j].coup           := ListeCaseVides[ii].coup;                   ListeFinale[j].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                 end               else                 begin                   inc(k);                   ListeTemp[k].coup           := ListeCaseVides[ii].coup;                   ListeTemp[k].indexDansKiller := ListeCaseVides[ii].indexDansKiller;                 end;          end;          for ii := 1 to k do       begin         ListeFinale[j+ii].coup           := ListeTemp[ii].coup;         ListeFinale[j+ii].indexDansKiller := ListeTemp[ii].indexDansKiller;       end;   end;    procedure TrierSelonDivergence;  {faible mobilite adverse d'abord}   label finBoucleFor;   var i,j,k,nbCoups,mobAdverse,CoupTest,coupdiv:longint;       x,dx,t:longint;       platDiv:plOth;   begin     platDiv := plat;     nbCoups := 0;     for i := 1 to nbVidesTrouvees do       begin         CoupTest := ListeFinale[i].coup;         if ModifPlatSeulement(CoupTest,platDiv,couleur)            then             begin               inc(nbCoups);               if (CoupTest=conseilHash)                 then                   mobAdverse := -2000000                 else                   begin                                        mobAdverse := 0;                     for j := 1 to nbVidesTrouvees do                       begin                         coupDiv := ListeCaseVides[j].coup;                         if platDiv[coupDiv]=pionVide then                           begin                             for t := dirPriseDeb[coupDiv] to dirPriseFin[coupDiv] do                               begin                                 dx := dirPrise[t];                                 x := coupDiv+dx;                                 if platDiv[x]=couleur then                                   begin                                     repeat                                       x := x+dx;                                     until platDiv[x]<>couleur;                                     if (platDiv[x] = -couleur) then                                       begin                                         inc(mobAdverse);                                         if estUnCoin[coupDiv] then inc(mobAdverse);                                         goto finBoucleFor;                                       end;                                   end;                               end;                             finBoucleFor:                           end;                       end;                   end;                                                     k := 1;               while (ClassDiv[k].mobAdv<=mobAdverse) & (k<nbCoups) do inc(k);               for j := nbCoups downto succ(k) do ClassDiv[j].coup := ClassDiv[pred(j)].coup;               for j := nbCoups downto succ(k) do ClassDiv[j].mobAdv := ClassDiv[pred(j)].mobAdv;               for j := nbCoups downto succ(k) do ClassDiv[j].indexDansKiller := ClassDiv[pred(j)].indexDansKiller;               ClassDiv[k].coup := CoupTest;               ClassDiv[k].mobAdv := mobAdverse;               ClassDiv[k].indexDansKiller := ListeFinale[i].indexDansKiller;                 platDiv := plat;             end;       end;        for i := 1 to nbCoups do       begin         listeFinale[i].coup := ClassDiv[i].coup;         listeFinale[i].indexDansKiller := ClassDiv[i].indexDansKiller;       end;     nbCoupsPourCoul := nbCoups;   end;  begin if (interruptionReflexion=pasdinterruption) then    begin   if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);                   conseilHash := 0;   DoitRemplirTableHashSimple := (ESprof>=profondeurRemplissageHash);   {DoitRemplirTableHashSimple := false;}      if ESprof>=ProfUtilisationHash     then        begin         ClefHashage := BXOR(ClefHashage , IndiceHash^^[couleur,pere]);         if ESprof>=profondeurRemplissageHash            then              begin               clefHashConseil := BAND(ClefHashage,32767);               conseilHash := HashTable^^[clefHashConseil];             end;       {         if (ESprof>=ProfPourHashExacte) & (ESprof>=profondeurRemplissageHash) then            begin             nroTableExacte := BAND(ClefHashage div 1024,nbTablesHashExactesMoins1);             clefHashExacte := BAND(ClefHashage,1023);             QuelleHashTableExacte := HashTableExacte[nroTableExacte];             QuelleCoupsLegauxHash := CoupsLegauxHash[nroTableExacte];             CreeCodePosition;             DoitRemplirTableHashSimple := not(PositionEstDansHashTableExacte);           end;        }        end;                                EtablitListeCasesVides;   TrierCasesVidesIsolees;   nbCoupsPourCoul := nbVidesTrouvees;   if ESprof>=profTriSelonDivergence then TrierSelonDivergence;         adversaire := -couleur;   profMoins1 := pred(ESprof);      maxPourBestDef := -noteMax;   aJoue := false;    nbEvalue := 0;     platEssai := plat;   jouablEssai := joua;   nbBlcEssai := nBla;   nbNrEssai := nNoi;    frontEssai := fr;         for i := 1 to nbCoupsPourCoul do     with ListeFinale[i] do       BEGIN        iCourant := coup;                (*** pour debugage seulement ***)        {if iCourant<11 then debugger else        if iCourant>88 then debugger else        if platEssai[iCourant]<>pionVide then debugger;}                        if ModifPlatLongint(iCourant,couleur,platEssai,jouablEssai,nbBlcEssai,nbNrEssai,frontessai) then           begin            aJoue := true;                        {$IFC not(GENERATING68K) }            EnleverDeLaListeChaineeDesCasesVides(iCourant);            {$ENDC}                        if (profMoins1<=profondeurArretPreordre-2)              then                 begin                  if (profMoins1=profondeurArretPreordre-2)                    then evaluerMaintenant := not(EstTurbulent(platEssai,adversaire,nbBlcEssai,nbNrEssai,frontEssai,caseCritiqueTurbulence))                    else evaluerMaintenant := true;                end              else                if (profMoins1>profondeurArretPreordre)                  then evaluerMaintenant := false                  else                     begin                      evaluerMaintenant := not(EstTurbulent(platEssai,adversaire,nbBlcEssai,nbNrEssai,frontEssai,caseCritiqueTurbulence));                      if evaluerMaintenant & not(utilisationNouvelleEval) then                        evaluerMaintenant := PasDeBordDeCinqAttaque(adversaire,frontessai,platessai);                      if evaluerMaintenant then                        evaluerMaintenant := not(PeutPrendreUnCoin(adversaire,platEssai));                    end;                          if evaluerMaintenant              then                 begin                  noteCourante := -Evaluation(platEssai,adversaire,nbBlcEssai,nbNrEssai,jouablEssai,frontEssai,false,-beta,-alpha,bidlong);                end              else                begin                if (nbEvalue<=0)                  then                    begin                    noteCourante := -ABPreOrdre(platEssai,jouablEssai,bestSuite,iCourant,adversaire,profMoins1,                                   -beta,-alpha,nbBlcEssai,nbNrEssai,frontEssai);                    nbEvalue := 1;                   end                 else                   begin                    noteCourante := -ABPreOrdre(platEssai,jouablEssai,bestSuite,iCourant,adversaire,profMoins1,                                   pred(-alpha),-alpha,nbBlcEssai,nbNrEssai,frontEssai);                    if (alpha<noteCourante) & (noteCourante<beta) then                      noteCourante := -ABPreOrdre(platEssai,jouablEssai,bestSuite,iCourant,adversaire,profMoins1,                                   -beta,-noteCourante,nbBlcEssai,nbNrEssai,frontEssai);                   end;                end;                             {$IFC not(GENERATING68K) }             RemettreDansLaListeChaineeDesCasesVides(iCourant);             {$ENDC}                          if (noteCourante>maxPourBestDef) then                 begin                  maxPourBestDef := noteCourante;                  Meidef := iCourant;                  if (noteCourante>alpha) then                     begin                      alpha := noteCourante;                      if (alpha>=beta) then                          begin                           ABPreOrdre := maxPourBestDef;                                                      if indexDansKiller>nbCoinsVidesPlus1 then                              begin                                for k := indexDansKiller downto nbCoinsVidesPlus2 do                                    ListeKiller[ESprof,k] := ListeKiller[ESprof,pred(k)];                                ListeKiller[ESprof,nbCoinsVidesPlus1] := iCourant;                              end;                                                      if ESprof>=ProfUtilisationHash then                             begin                               if DoitRemplirTableHashSimple then                                  HashTable^^[clefHashConseil] := MeiDef;                               ClefHashage := BXOR(ClefHashage,IndiceHash^^[couleur,pere]);                             end;                           fils[pere] := iCourant;                           exit(ABPreOrdre)                         end;                    end;                end;                          platEssai := plat;             jouablEssai := joua;             nbBlcEssai := nBla;             nbNrEssai := nNoi;               frontEssai := fr;                         end;     END;     if Ajoue    then       begin                        if ESprof>=ProfUtilisationHash then          begin            if DoitRemplirTableHashSimple then HashTable^^[clefHashConseil] := MeiDef;            ClefHashage := BXOR(ClefHashage,IndiceHash^^[couleur,pere]);          end;                        fils[pere] := Meidef;        ABPreOrdre := maxPourBestDef;      end    else      begin        if ESprof>=ProfUtilisationHash then          ClefHashage := BXOR(ClefHashage,IndiceHash^^[couleur,pere]);        if DoitPasserFin(adversaire,plat)           then            if utilisationNouvelleEval               then                 if couleur=pionBlanc                   then ABPreOrdre := 100*(nBla-nNoi)                  else ABPreOrdre := 100*(nNoi-nBla)              else                if couleur=pionBlanc                   then ABPreOrdre := 500*(nBla-nNoi)                  else ABPreOrdre := 500*(nNoi-nBla)          else            ABPreOrdre := -ABPreOrdre(plat,joua,Meidef,pere,adversaire,ESprof,-beta,-alpha,nBla,nNoi,fr);          end;      end;    end;   { ABPreOrdre }procedure AnnonceRechercheDansRapport(numeroCoup:longint);var s,s1:str255;begin  if interruptionReflexion=pasdinterruption then  if not(rechercheDejaAnnonceeDansRapport) & not(demo) then    if numeroCoup<48 then      begin        NumToString(numeroCoup,s1);        if bestMode           then s := ParamStr(ReadRscString(TextesRapportID,5),s1,'','','')   {'Recherche au coup ^0 : finale parfaite'}          else if typeCalculFinale=ReflPseudo            then s := ParamStr(ReadRscString(TextesRapportID,3),s1,'','','') {'Recherche au coup ^0 : pseudo-finale'}            else s := ParamStr(ReadRscString(TextesRapportID,4),s1,'','','');{'Recherche au coup ^0 : finale gagnante'}        DisableKeyboardScriptSwitch;        FinRapport;        TextNormalDansRapport;        ChangeFontFaceDansRapport([bold]);        WritelnDansRapport(s);        ChangeFontFaceDansRapport([]);        EnableKeyboardScriptSwitch;        rechercheDejaAnnonceeDansRapport := true;      end;end;procedure MeilleureSuiteDansRapport;var s:str255;begin  if not(demo) then    begin      AnnonceRechercheDansRapport(noCoupRecherche);      s := MeilleureSuiteEnChaine(1,true,true,true,false,0);      EnleveEtCompteEspacesDeGauche(s,bidint);      DisableKeyboardScriptSwitch;      FinRapport;      TextNormalDansRapport;      WritelnDansRapport('  '+s);      EnableKeyboardScriptSwitch;    end;end;procedure MetInfosTechniquesDansRapport;var s,s1,s2,s3:str255;    nbMinutes:longint;begin  if rechercheDejaAnnonceeDansRapport then   if (interruptionReflexion=pasdinterruption) then      if not(demo) then     begin       TempsglobalDeLaFonction := TickCount()-TempsglobalDeLaFonction;       nbMinutes := TempsglobalDeLaFonction div 3600;       if nbMinutes<=0          then           begin             GetIndString(s,TextesRapportID,15);             s := ParamStr(s,ReelEnString(1.0*TempsglobalDeLaFonction/60),'','','');           end         else           if nbMinutes>=60             then               begin                 GetIndString(s,TextesRapportID,13);                 NumToString(nbMinutes div 60,s1);                 NumToString(nbMinutes mod 60,s2);                 NumToString((TempsglobalDeLaFonction-nbMinutes*3600) div 60,s3);                 s := ParamStr(s,ReelEnString(1.0*TempsglobalDeLaFonction/60),s1,s2,s3);               end             else               begin                 GetIndString(s,TextesRapportID,14);                 NumToString(nbMinutes,s2);                 NumToString((TempsglobalDeLaFonction-nbMinutes*3600) div 60,s3);                 s := ParamStr(s,ReelEnString(1.0*TempsglobalDeLaFonction/60),s2,s3,'');               end;       DisableKeyboardScriptSwitch;       FinRapport;       TextNormalDansRapport;       WritelnDansRapport('  '+s);       EnableKeyboardScriptSwitch;            s1 := '';       if nbreToursNoeudsGeneresFinale>0 then         begin           if nbreToursNoeudsGeneresFinale>1 then             begin               NumToString(nbreToursNoeudsGeneresFinale,s1);               s1 := s1+' * ';             end;           s1 := s1+'2147483647 + ';         end;       NumToString(nbreNoeudsGeneresFinale,s);       s := ReadRscString(TextesRapportID,12)+s1+StringOf(' ')+s;       WritelnDansRapport('  '+s);            end;end;procedure CompleteMeilleureSuite(miniprof:longint;var whichPlat:plOth;coulDefense,WhichNbBlanc,WhichNbNoir,scorePourVerif:longint);var platCompl:plOth;    platComplEndgame:plOthEndgame;    nBlaCompl,nNoiCompl,aQuiCompl:longint;    scoreSuite,coup,p,i,pere,bidBestSuite:longint;    coupPossible,PartieFinie:boolean;    s,s1,s2:str255;begin if (interruptionReflexion=pasdinterruption) then    begin     if miniprof>= (profForceBrute+1)    then for i := 1 to profForceBrute do meilleureSuite[miniprof,i] := 0    else for i := 1 to miniprof-1 do meilleureSuite[miniprof,i] := 0;  platCompl := whichPlat;  nBlaCompl := WhichNbBlanc;  nNoiCompl := WhichNbNoir;  AquiCompl := coulDefense;    p := miniprof+1;  repeat    p := p-1;    coup := meilleuresuite[miniprof,p];    coupPossible := false;    if (coup>=11) & (coup<=88) then      if platCompl[coup]=pionVide then        begin          coupPossible := ModifPlatFinLongint(Coup,AquiCompl,platCompl,nBlaCompl,nNoiCompl);          if coupPossible             then AquiCompl := -AquiCompl            else coupPossible := ModifPlatFinLongint(Coup,-AquiCompl,platCompl,nBlaCompl,nNoiCompl);        end;  until (p<=1) | (coup=0) |  not(couppossible);    PartieFinie := DoitPasserFin( AquiCompl,platCompl) &                DoitPasserFin(-AquiCompl,platCompl);        if not(partieFinie) then                 if not(coupPossible) then      begin        if p>profForceBrute then           begin            SysBeep(0);            GetIndString(s,TextesRapportID,21);            NumToString(p,s1);            s := ParamStr(s,s1,'','','');            WritelnDansRapport(s);            AlerteSimple(s);          end;        pere := meilleuresuite[miniprof,p+1];                CopyEnPlOthEndgame(platCompl,platComplEndgame);        if AquiCompl=pionNoir          then            if AquiCompl=coulDefense              then scoreSuite := -ABFinPetitePourSuite(platComplEndgame,bidBestSuite,AquiCompl,p,                                                     -notemax,notemax,nNoiCompl-nBlaCompl,false)              else scoreSuite := ABFinPetitePourSuite(platComplEndgame,bidBestSuite,AquiCompl,p,                                                     -notemax,notemax,nNoiCompl-nBlaCompl,false)          else            if AquiCompl=coulDefense              then scoreSuite := -ABFinPetitePourSuite(platComplEndgame,bidBestSuite,AquiCompl,p,                                                     -notemax,notemax,nBlaCompl-nNoiCompl,false)              else scoreSuite := ABFinPetitePourSuite(platComplEndgame,bidBestSuite,AquiCompl,p,                                                     -notemax,notemax,nBlaCompl-nNoiCompl,false);                                                             if abs(scorePourVerif-scoreSuite)>1 then          if (interruptionReflexion=pasdinterruption) then             begin            SysBeep(0);            NumToString(scorePourVerif,s1);            NumToString(scoreSuite,s2);            GetIndString(s,TextesRapportID,22);            s := ParamStr(s,s1,s2,'','');            WritelnDansRapport(s);                        AlerteSimple(s);                        NumToString(nBlaCompl,s);            NumToString(nNoiCompl,s1);            s := '(nBlaCompl='+s+'  et nNoiCompl='+s1+StringOf(')');            WritelnDansRapport(s);            NumToString(pere,s);            NumToString(AquiCompl,s1);            s := '(pere='+s+'  et AquiCompl='+s1+StringOf(')');            WritelnDansRapport(s);            NumToString(p,s);            s := '(p='+s+StringOf(')');            WritelnDansRapport(s);                                  end;        for i := p downto 1 do          meilleureSuite[miniprof,i] := meilleureSuite[p,i];      end;  end;end;procedure GestionMeilleureSuite(ProfRecherche:longint;var jeu:plOth;couleur,nbBla,nbNoi,                                valXY,Xcourant,nroCoup,nbreCoups:longint);var message,i:longint;begin  if analyseRetrograde.enCours &      {(analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeParfait) &}     (Xcourant=coupDontLeScoreEstConnu)     then exit(GestionMeilleureSuite);   message := pasdemessage;  if (valXY>0) & (not(bestMode) | passeDeRechercheAuMoinsNulle) then message := messageEstGagnant;  if (valXY=0) & (not(bestMode) | passeDeRechercheAuMoinsNulle) then message := messageFaitNulle;  if (valXY<0) & (not(bestMode) | passeDeRechercheAuMoinsNulle) then    if nroCoup<nbreCoups      then message := messageEstPerdant      else         if typeCalculFinale=reflPseudo          then message := messageToutEstProbablementPerdant          else message := messageToutEstPerdant;            if bestMode & not(passeDeRechercheAuMoinsNulle) & (interruptionReflexion=pasdinterruption) then      CompleteMeilleureSuite(ProfRecherche,jeu,couleur,nbBla,nbNoi,valXY);  for i := ProfRecherche downto 1 do suiteJouee[i] := meilleureSuite[ProfRecherche,i];  if (interruptionReflexion=pasdinterruption) then    SauvegardeMeilleureSuite(Xcourant,suiteJouee,@meilleureSuite,couleur,                           jeu,nbBla,nbNoi,message);  meilleureSuiteStr^^ := MeilleureSuiteEnChaine(1,true,true,true,false,0);  if afficheMeilleureSuite then EcritMeilleureSuite;  if bestMode | (valXY>=0) |     (message=messageToutEstPerdant) |     (message=messageToutEstProbablementPerdant) then     if commentaireDansRapport then      if (ProfRecherche+1)>10 then MeilleureSuiteDansRapport;end;function CalculMilieuDePartie(var plat:plOth;var jouable:plBool;                              var defense:longint;coup,couleur:longint;                              nbBlanc,nbNoir:longint;                              var frontMilieu:InfoFrontRec):longint;begin  SetLargeurFenetreProbCut;    profondeurPreordre := 1;  if MFprof>14 then profondeurPreordre := profondeurPreordre+1;  if MFprof>20 then profondeurPreordre := profondeurPreordre+1;    clefHashage := 0;  profondeurArretPreordre := MFniv-profondeurPreordre;  profondeurDepartPreordre := MFniv;    CalculMilieuDePartie := ABPreOrdre(plat,jouable,defense,coup,couleur,profondeurDepartPreordre,                          -30000,30000,nbBlanc,nbNoir,frontMilieu)end;procedure PreordonnancementDesCoups;var i:longint;begin  if (MFniv>8) then    begin            Calcule_Valeurs_Tactiques(jeu,false);      LanceChrono;      LanceChronoCetteProf;      tempsAlloue := 1000000000;  {pour ne pas se faire interrompre pendant l'ordonnancement}            for i := 1 to nbCoup do         begin          classement[i].note := -32000;          classement[i].noteMilieuDePartie := -32000;          classement[i].notePourLeTri := -32000;          classement[i].delta := kTypeMilieuDePartie;        end;      if doitEcrireReflexFinale then        case typeCalculFinale of          ReflPseudo:            SetValReflexFinale(classement,MFniv,nbcoup,nbcoup,ReflTriPseudo,noCoupRecherche,maxint);          ReflGagnant,ReflRetrogradeGagnant:            SetValReflexFinale(classement,MFniv,nbcoup,nbcoup,ReflTriGagnant,noCoupRecherche,maxint);          ReflParfait,ReflRetrogradeParfait:            SetValReflexFinale(classement,MFniv,nbcoup,nbcoup,ReflTriParfait,noCoupRecherche,maxint);          otherwise            SetValReflexFinale(classement,MFniv,nbcoup,nbcoup,ReflTriGagnant,noCoupRecherche,maxint);        end;               if affichageReflexion.doitAfficher & doitEcrireReflexFinale then EcritReflexion;            maxPourOrdonnancement := -32000;      for i := 1 to nbCoup do        if (interruptionReflexion=pasdinterruption) then             begin             iCourant := classement[i].x;             platClass := jeu;             jouableClass := empl;             nbBlancClass := nbBl;             nbNoirClass := nbNo;             frontClass := frontiereFinale;             bidbool := ModifPlatLongint(iCourant,coulPourMeilleurFin,platClass,jouableClass,                            nbBlancClass,nbNoirClass,frontClass);                          {$IFC not(GENERATING68K) }             EnleverDeLaListeChaineeDesCasesVides(iCourant);             {$ENDC}                          {             noteClass := -Evaluation(platClass,Couldefense,nbBlancClass,nbNoirClass,                                 jouableClass,frontClass,false,-30000,30000,bdilong);                         }                                                    noteclass := -CalculMilieuDePartie(platClass,jouableClass,defense,iCourant,coulDefense,                                              nbBlancClass,nbNoirClass,frontClass);                        {                        +2500-50*proofNumber(platClass,3,coulDefense,coulPourMeilleurFin,maxlongint);                        }                                       {$IFC not(GENERATING68K) }             RemettreDansLaListeChaineeDesCasesVides(iCourant);             {$ENDC}                          if quadrantEstImpair[numeroQuadrant[iCourant]] & not(utilisationNouvelleEval)                then noteclass := noteclass+400;              if (nbVidesQuadr[numeroQuadrant[iCourant]]=1) then               if PeutJouerIci(coulDefense,iCourant,jeu) then noteclass := noteclass+4000;                                         classement[i].note := noteclass;             classement[i].noteMilieuDePartie := noteclass;                 classement[i].def := defense;             classement[i].delta := kTypeMilieuDePartie;             fils[iCourant] := defense;                          if noteclass>maxPourOrdonnancement then maxPourOrdonnancement := noteclass;                              if doitEcrireReflexFinale then               case typeCalculFinale of                 ReflPseudo:                   SetValReflexFinale(classement,MFniv,i,nbcoup,ReflTriPseudo,noCoupRecherche,maxint);                 ReflGagnant,ReflRetrogradeGagnant:                   SetValReflexFinale(classement,MFniv,i,nbcoup,ReflTriGagnant,noCoupRecherche,maxint);                 ReflParfait,ReflRetrogradeParfait:                   SetValReflexFinale(classement,MFniv,i,nbcoup,ReflTriParfait,noCoupRecherche,maxint);                 otherwise                   SetValReflexFinale(classement,MFniv,i,nbcoup,ReflTriGagnant,noCoupRecherche,maxint);               end;             if affichageReflexion.doitAfficher & doitEcrireReflexFinale then EcritReflexion;                       end;      limSup := notemax;      compt := 0;      repeat          maxPourOrdonnancement := -noteMax;         for i := 1 to nbCoup do           if (classement[i].note>=maxPourOrdonnancement) & (classement[i].note<limSup)             then maxPourOrdonnancement := classement[i].note;         for i := 1 to nbCoup do           if classement[i].note=maxPourOrdonnancement             then               begin                 compt := compt+1;                 classProv[compt] := classement[i];               end;         limSup := maxPourOrdonnancement;      until (compt>=nbCoup) | (limSup<=-notemax);      for i := 1 to nbCoup do classement[i] := classProv[i];     end;end;function NegaCStar(lower,upper:longint;couleur,ProfRecherche,nbBla,nbNoi,Xcourant:longint;jeu:plOth;                      var meilleurCoup:longint;var InfosMilieuDePartie:t_InfosMilieuDePartie):longint;var v,t:longint;    SuiteOK:boolean;begin  FenetreLargePourRechercheScoreExact := false;  SuiteOK := false;  repeat    v := 2*((lower+upper) div 4);    t := -LanceurABFin(jeu,meilleurCoup,XCourant,couleur,ProfRecherche,                  -v-1,-v+1,nbBla,nbNoi,bidlong,InfosMilieuDePartie);    if t=v then SuiteOK := true;    if t>=v then lower := t;    if t<=v then upper := t;        WriteStringAndNumAt('lower=',-upper,10,30);    WriteStringAndNumAt('upper=',-lower,10,40);    WriteStringAndNumAt('v=',-v,110,30);    WriteStringAndNumAt('t=',-t,110,40);      until SuiteOK | (lower>=upper) | (interruptionReflexion<>pasdinterruption);  NegaCStar := t;end;function Algo_SSSStar(lower,upper:longint;couleur,ProfRecherche,nbBla,nbNoi:longint;jeu:plOth;                      var meilleurCoup:longint;var InfosMilieuDePartie:t_InfosMilieuDePartie):longint;var v,t:longint;const perefictif=44;begin    bestMode := false;  FenetreLargePourRechercheScoreExact := false;  ClefHashage := IndiceHash^^[couleur,pereFictif];    t := upper;  repeat    v := t;    t := -LanceurABFin(jeu,meilleurCoup,perefictif,couleur,ProfRecherche,-v,-v+1,nbBla,nbNoi,bidlong,InfosMilieuDePartie);    EssaieSetPortWindowPlateau;    WriteStringAndNumAt('SSS* score>=',-t,10,40);  until (t=v) | (t<=lower) |        (interruptionReflexion<>pasdinterruption);          Algo_SSSStar := -t;    end;function Algo_AlphaBetaBrut(lower,upper:longint;couleur,ProfRecherche,nbBla,nbNoi:longint;jeu:plOth;                      var meilleurCoup:longint;var InfosMilieuDePartie:t_InfosMilieuDePartie):longint;var t:longint;const perefictif=44;begin  bestMode := false;  FenetreLargePourRechercheScoreExact := true;  ClefHashage := IndiceHash^^[couleur,pereFictif];      t := -LanceurABFin(jeu,meilleurCoup,perefictif,couleur,ProfRecherche,-upper,-lower,nbBla,nbNoi,bidlong,InfosMilieuDePartie);  EssaieSetPortWindowPlateau;  WriteStringAndNumAt('AlphaBeta score=',-t,10,30);  FenetreLargePourRechercheScoreExact := false;    Algo_AlphaBetaBrut := -t;    end;function Algo_NegaCStar(lower,upper:longint;couleur,ProfRecherche,nbBla,nbNoi:longint;jeu:plOth;                      var meilleurCoup:longint;var InfosMilieuDePartie:t_InfosMilieuDePartie):longint;var t:longint;const perefictif=44;begin  bestMode := false;  ClefHashage := IndiceHash^^[couleur,pereFictif];    t := NegaCStar(lower,upper,couleur,ProfRecherche,nbBla,nbNoi,perefictif,jeu,meilleurCoup,InfosMilieuDePartie);          Algo_NegaCStar := -t;    end;function MinimaxFinale(couleur,MiniProf,longClass,nbBla,nbNoi:longint;var jeu:plOth;                    var empl:plBool;var frontiereMinimax:InfoFrontRec;var class:ListOfMoveRecords):longint;var Xcourant:longint;          valXY:longint;    platMod:plOth;    jouableMod:plBool;    nbBlancMod,nbNoirMod:longint;    frontMod:InfoFrontRec;    InfosMod:t_InfosMilieuDePartie;    sortieDeBoucle:boolean;    toutesLesPassesTerminees:boolean;    classAux:ListOfMoveRecords;    i,j,k,compteur:longint;    indice_du_meilleur:longint;    noteModif:longint;    bestAB,betaAB:longint;    MaxConnuSiToutEstPerdant:longint;    TickChronoPourClassaux,TempsDeXCourant:longint;    NoteMilieuDeXCourant,NotePourLeTriDeXCourant:longint;procedure SetNoteDansElementClassement(var classement:ListOfMoveRecords;index,valeur:longint;var tickchrono:longint);begin  if not(EstLaListeDesCoupsDeFenetreReflexion(classement)) | doitEcrireReflexFinale then    with classement[index] do      begin        note := valeur;        delta := kDeltaFinaleInfini;        if (@classement<>@classAux) then          begin            temps := temps+(TickCount()-tickchrono);            tickchrono := TickCount();          end;      end;  if EstLaListeDesCoupsDeFenetreReflexion(classement) then     if affichageReflexion.doitAfficher then EcritReflexion;end;function calculNormal(XCourant:longint):longint;var t,bas_fenetre,haut_fenetre:longint;    n,ticks:longint;begin  n := nbreNoeudsGeneresFinale;  ticks := TickCount();    ClefHashage := 0;  if bestMode & (compteur>1)    then      begin        FenetreLargePourRechercheScoreExact := false;        t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                    Max(-bestAB-1,-64),Min(-bestAB,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);                            if (interruptionReflexion=pasdinterruption) then        if (bestAB<t) & (t<betaAB) then           repeat             FenetreLargePourRechercheScoreExact := false;             SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);                          FenetreLargePourRechercheScoreExact := true;             bas_fenetre := t-1;             haut_fenetre := Min(bas_fenetre+10,betaAB);             t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                         Max(-haut_fenetre,-64),Min(-bas_fenetre,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);           until ((bas_fenetre<t) & (t<haut_fenetre)) | (t>=betaAB) |                 (interruptionReflexion<>pasdinterruption);                {          begin            SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);            t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                        Max(-betaAB,-64),Min(-t+1,64),nbBlancMod,nbNoirMod,bidlong);          end;        }      end    else      begin        FenetreLargePourRechercheScoreExact := false;        t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                  Max(-betaAB,-64),Min(-bestAB,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);       end;  calculNormal := t;    {  n := nbreNoeudsGeneresFinale-n;  ticks := TickCount()-ticks;  WriteStringAndNumAt('nb nœuds/sec=',(n*60) div ticks,30,80);  }end;function SSS_Dual(XCourant:longint):longint;var t,bas_fenetre,haut_fenetre,lower,upper:longint;    n,ticks:longint;begin  n := nbreNoeudsGeneresFinale;  ticks := TickCount();    ClefHashage := 0;          if not(bestMode)    then      begin        FenetreLargePourRechercheScoreExact := false;        t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,            Max(-betaAB,-64),Min(-bestAB,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);       end    else      if compteur=1         then           begin            t := NegaCStar(-64,64,coulDefense,MiniProf,nbBlancMod,nbNoirMod,Xcourant,platMod,defense,InfosMod);                        SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);          end        else          begin            FenetreLargePourRechercheScoreExact := false;            upper := betaAB;            lower := Max(-64,bestAB);            t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                        Max(-lower-1,-64),Min(-lower,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);                                                                      if (interruptionReflexion=pasdinterruption) then            if (lower<t) & (t<upper) then               repeat                 FenetreLargePourRechercheScoreExact := false;                 SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);                                  FenetreLargePourRechercheScoreExact := true;                 bas_fenetre := t-1;                 haut_fenetre := Min(t+9,upper);                 t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                             Max(-haut_fenetre,-64),Min(-bas_fenetre,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);               until ((bas_fenetre<t) & (t<haut_fenetre)) | (t>=upper) |                     (interruptionReflexion<>pasdinterruption);           end;  SSS_Dual := t;          {  n := nbreNoeudsGeneresFinale-n;  ticks := TickCount()-ticks;  WriteStringAndNumAt('nb nœuds/sec=',(n*60) div ticks,30,80);  }end;function Dicho_first(XCourant:longint):longint;var t,bas_fenetre,haut_fenetre,lower,upper:longint;    n,ticks:longint;begin  n := nbreNoeudsGeneresFinale;  ticks := TickCount();    ClefHashage := 0;          if not(bestMode)    then      begin        FenetreLargePourRechercheScoreExact := false;        t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,-betaAB,-bestAB,nbBlancMod,nbNoirMod,bidlong,InfosMod);       end    else      if passeDeRechercheAuMoinsNulle then        begin          FenetreLargePourRechercheScoreExact := false;          lower := -64;          upper := 64;                    t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,-1,1,nbBlancMod,nbNoirMod,bidlong,InfosMod);                     if (t>0) & (interruptionReflexion=pasdinterruption) then            repeat                            classAux[compteur].note := t;              classAux[compteur].delta := kDeltaFinaleInfini;              if doitEcrireReflexFinale then                 if analyseRetrograde.enCours                  then SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflRetrogradeParfait,noCoupRecherche,compteur)                  else SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflParfait,noCoupRecherche,compteur);              SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);                            FenetreLargePourRechercheScoreExact := true;              passeDeRechercheAuMoinsNulle := false;              bas_fenetre := Max(t-1,lower);              haut_fenetre := Min(t+9,upper);              t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                           -haut_fenetre,-bas_fenetre,nbBlancMod,nbNoirMod,bidlong,InfosMod);            until ((bas_fenetre<t) & (t<haut_fenetre)) | (t>=upper) |                   (interruptionReflexion<>pasdinterruption);                             passeDeRechercheAuMoinsNulle := not(t>=0);        end        else          if compteur=1             then               begin                FenetreLargePourRechercheScoreExact := false;                lower := -64;                upper := 64;                                t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,-1,1,nbBlancMod,nbNoirMod,bidlong,InfosMod);                                 if odd(t) then if t>0 then t := t+1 else t := t-1;                                if (t>0) & (interruptionReflexion=pasdinterruption) then                  repeat                                        classAux[compteur].note := t;                    classAux[compteur].delta := kDeltaFinaleInfini;                    if doitEcrireReflexFinale then                       if analyseRetrograde.enCours                        then SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflRetrogradeParfait,noCoupRecherche,compteur)                        else SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflParfait,noCoupRecherche,compteur);                    SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);                                        FenetreLargePourRechercheScoreExact := true;                    bas_fenetre := Max(t-1,lower);                    haut_fenetre := Min(t+9,upper);                    t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                                -haut_fenetre,-bas_fenetre,nbBlancMod,nbNoirMod,bidlong,InfosMod);                  until ((bas_fenetre<t) & (t<haut_fenetre)) | (t>=upper) |                        (interruptionReflexion<>pasdinterruption);                                         if (t<0) & (interruptionReflexion=pasdinterruption) then                  repeat                                      classAux[compteur].note := t;                    classAux[compteur].delta := kDeltaFinaleInfini;                    if doitEcrireReflexFinale then                       if analyseRetrograde.enCours                        then SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflRetrogradeParfait,noCoupRecherche,compteur)                        else SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflParfait,noCoupRecherche,compteur);                    SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);                                        FenetreLargePourRechercheScoreExact := true;                    bas_fenetre := Max(t-9,lower);                    haut_fenetre := Min(t+1,upper);                    t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                                 -haut_fenetre,-bas_fenetre,nbBlancMod,nbNoirMod,bidlong,InfosMod);                  until ((bas_fenetre<t) & (t<haut_fenetre)) | (t<=lower) |                         (interruptionReflexion<>pasdinterruption);                                       end            else              begin                lower := Max(-64,bestAB);                upper := Min(betaAB,64);                                FenetreLargePourRechercheScoreExact := false;                t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                            Max(-lower-1,-64),Min(-lower,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);                                                                              if (interruptionReflexion=pasdinterruption) then                if (lower<t) & (t<upper) then                   repeat                     SetNoteDansElementClassement(ReflexData^.class,compteur,t,tickChrono);                                          FenetreLargePourRechercheScoreExact := true;                     bas_fenetre := Max(t-1,lower);                     haut_fenetre := Min(t+9,upper);                     t := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,                                 -haut_fenetre,-bas_fenetre,nbBlancMod,nbNoirMod,bidlong,InfosMod);                   until ((bas_fenetre<t) & (t<haut_fenetre)) | (t>=upper) |                         (interruptionReflexion<>pasdinterruption);               end;  Dicho_first := t;          {  n := nbreNoeudsGeneresFinale-n;  ticks := TickCount()-ticks;  WriteStringAndNumAt('nb nœuds/sec=',(n*60) div ticks,30,80);  }end;function CalculParAnalyseDeFinale(XCourant:longint):longint;var aux:longint;begin  FenetreLargePourRechercheScoreExact := true;  ClefHashage := 0;  aux := -LanceurABFin(platMod,defense,XCourant,coulDefense,MiniProf,              Max(-infini,-64),Min(infini,64),nbBlancMod,nbNoirMod,bidlong,InfosMod);  if (interruptionReflexion=pasdinterruption) then     CompleteMeilleureSuite(miniprof,platMod,coulDefense,nbBlancMod,nbNoirMod,aux);  CalculParAnalyseDeFinale := aux;end;procedure MetSuitePartieEnTete(messageHandle:MessageFinaleHdl;var bestAB:longint;                                var classAux:ListOfMoveRecords;var compteur:longint);var indiceDansClass,j,k,coupTete,coup:longint;    trouve,couppossible:boolean;    platTete:plOth;    nBlaTete,nNoiTete,aQuiTete:longint;    longueurSuite,scoresuite:longint;begin  longueurSuite := messageHandle^^.longueurData;  coupTete := messageHandle^^.data[0];  trouve := false;  indiceDansClass := 0;  repeat    indiceDansClass := indiceDansClass+1;    trouve := classAux[indiceDansClass].x=coupTete;  until trouve | (indiceDansClass>=longClass);    if trouve then    begin      platTete := jeu;      nBlaTete := nbBl;      nNoiTete := nbNo;      AQuiTete := coulPourMeilleurFin;      p := -1;      repeat        inc(p);        coup := messageHandle^^.data[p];        coupPossible := false;        if (coup>=11) & (coup<=88) then          if platTete[coup]=pionVide then            begin              coupPossible := ModifPlatFinLongint(Coup,AQuiTete,platTete,nBlaTete,nNoiTete);              if coupPossible                 then AQuiTete := -AQuiTete                else coupPossible := ModifPlatFinLongint(Coup,-AQuiTete,platTete,nBlaTete,nNoiTete);            end;      until (p>=longueurSuite) | (coup=0) | not(couppossible);            if coupPossible then        begin          if coulPourMeilleurFin=pionNoir            then scoresuite := nNoiTete-nBlaTete            else scoreSuite := nBlaTete-nNoiTete;          for j := indiceDansClass downto 2 do classAux[j] := classAux[j-1];          classAux[1].x := coupTete;          classAux[1].note := scoreSuite;          classAux[1].delta := kDeltaFinaleInfini;          k := 1;          classAux[1].def := messageHandle^^.data[k];          classAux[1].temps := 0;          classAux[1].noteMilieuDePartie := 0;          classAux[1].notePourLeTri := 0;          bestAB := scoresuite;          if betaAB<=bestAB then betaAB := succ(bestAB);          compteur := 1;          for j := 1 to longueurSuite do            meilleureSuite[miniprof,miniprof-j+1] := messageHandle^^.data[j];        end;          end;end;procedure MetBestAB(messageHandle:MessageFinaleHdl;var bestAB:longint);begin  bestAB := messageHandle^^.data[0];  if betaAB<=bestAB then betaAB := succ(bestAB);end;procedure EcritClassaux;var i:longint;begin  EssaieSetPortWindowPlateau;  WriteStringAndNumAt('case=',coupDontLeScoreEstConnu,10,10);  WriteStringAndNumAt('score connu=',scoreDuCoupDontLeScoreEstConnu,50,10);  for i := 1 to longClass do    begin      WriteStringAndNumAt('i=',i,10,20+10*i);      WriteStringAndNumAt('coup=',classAux[i].x,30,20+10*i);      WriteStringAndNumAt('score=',classAux[i].note,80,20+10*i);    end;  for i := 1 to 10 do    WriteStringAt('                                    ',10,20+(longClass+i)*10);end;procedure MetBestABEtCoupConnu(messageHandle:MessageFinaleHdl;var bestAB,coupDontLeScoreEstConnu:longint);var aux,i,k:longint;    TempoMoveRec:MoveRecord;begin  scoreDuCoupDontLeScoreEstConnu := messageHandle^^.data[0];   aux := 1;  coupDontLeScoreEstConnu := messageHandle^^.data[aux];  aux := 2;  defenseDuCoupDontLeScoreEstConnu := messageHandle^^.data[aux];  bestAB := scoreDuCoupDontLeScoreEstConnu;   if betaAB<=bestAB then betaAB := succ(bestAB);    k := maxint;  for i := 1 to longClass do    if classAux[i].x=coupDontLeScoreEstConnu then k := i;  if (k>1) & (k<=longClass) then    begin      TempoMoveRec := classAux[k];      for i := k downto 2 do classAux[i] := classAux[i-1];      classAux[1] := TempoMoveRec;    end;      classAux[1].note := scoreDuCoupDontLeScoreEstConnu;  classAux[1].def := defenseDuCoupDontLeScoreEstConnu;  classAux[1].delta := kDeltaFinaleInfini;  if doitEcrireReflexFinale then    if analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeGagnant      then        begin          SetValReflexFinale(classAux,MFniv,longClass,longClass,ReflRetrogradeGagnant,noCoupRecherche,maxint);          SetValReflexFinale(classAux,MFniv,1,longClass,ReflRetrogradeGagnant,noCoupRecherche,maxint);        end      else        begin          SetValReflexFinale(classAux,MFniv,longClass,longClass,ReflRetrogradeParfait,noCoupRecherche,maxint);          SetValReflexFinale(classAux,MFniv,1,longClass,ReflRetrogradeParfait,noCoupRecherche,maxint);        end;  if affichageReflexion.doitAfficher & doitEcrireReflexFinale then EcritReflexion;    for i := 2 to longClass do classAux[i].note := -infini;end;begin if (interruptionReflexion=pasdinterruption) then    begin  MyFillchar(@meilleureSuite,sizeof(meilleureSuite),chr(0));  indice_du_meilleur := longClass;  MaxConnuSiToutEstPerdant := -infini;    if bestMode    then      begin        bestAB := -infini;        betaAB := infini;        passeDeRechercheAuMoinsNulle := true;      end    else               {reduction de la fenetre}     begin       bestAB := -1;       betaAB := +1;       passeDeRechercheAuMoinsNulle := true;     end;  FenetreLargePourRechercheScoreExact := false;      classAux := class;    compteur := 0;    indexDuCoupDansFntrReflexion := compteur;    coupDontLeScoreEstConnu := 0;  if messageHandle<>NIL then    begin      typeDataDansHandle := messageHandle^^.typeData;      case typeDataDansHandle of        ReflRetrogradeParfait        : MetSuitePartieEnTete(messageHandle,bestAB,classAux,compteur);        ReflScoreDejaConnuFinale     : metBestAB(messageHandle,bestAB);        ReflScoreDeCeCoupConnuFinale : metBestABEtCoupConnu(messageHandle,bestAB,coupDontLeScoreEstConnu);      end;          end;  if analyseRetrograde.enCours & (analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeParfait) then    passeDeRechercheAuMoinsNulle := (scoreDuCoupDontLeScoreEstConnu < -2);  for i := 1 to 64 do classAux[i].note := -infini;                toutesLesPassesTerminees := false;  repeat    sortieDeBoucle := false;    compteur := 0;      repeat      if (interruptionReflexion=pasdinterruption) then        begin          if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);                    compteur := compteur+1;          indexDuCoupDansFntrReflexion := compteur;          Xcourant := classAux[compteur].x;          NoteMilieuDeXCourant := classAux[compteur].noteMilieuDePartie;          NotePourLeTriDeXCourant := classAux[compteur].notePourLeTri;          if (classAux[compteur].def>=11) & (classAux[compteur].def<=88) then            fils[Xcourant] := classAux[compteur].def;                              if not(RefleSurTempsJoueur) & (jeuCourant[Xcourant]=PionVide) & pionclignotant then            DessinePionMontreCoupLegal(Xcourant);                     platMod := jeu;          jouableMod := empl;          nbBlancMod := nbBla;          nbNoirMod := nbNoi;          frontMod := frontiereMinimax;          bidbool := ModifPlatLongint(XCourant,couleur,platMod,jouableMod,nbBlancMod,nbNoirMod,frontMod);          with InfosMod do            begin              jouable := jouableMod;              nbBlancs := nbBlancMod;              nbNoirs := nbNoirMod;              frontiere := frontMod;            end;                    {$IFC not(GENERATING68K) }          EnleverDeLaListeChaineeDesCasesVides(XCourant);          {$ENDC}                    TickChrono := TickCount();          TickChronoPourClassaux := TickCount();          if MiniProf<=0 then            begin              if Couldefense=pionBlanc                  then                    if nbBlancMod<nbNoirMod                     then noteModif := nbBlancMod+nbBlancMod-64                     else noteModif := 64-nbNoirMod-nbNoirMod                 else                    if nbBlancMod<nbNoirMod                     then noteModif := 64-nbBlancMod-nbBlancMod                     else noteModif := nbNoirMod+nbNoirMod-64;              if nbBlancMod=nbNoirMod then notemodif := 0;              valXY := -noteModif;            end          else             begin              if XCourant=coupDontLeScoreEstConnu                then                   begin                    valXY := scoreDuCoupDontLeScoreEstConnu;                    defense := defenseDuCoupDontLeScoreEstConnu;                  end                else                  begin                                              if (MFniv>15) then                       bidint := -CalculMilieuDePartie(platMod,jouableMod,defense,Xcourant,coulDefense,                                                    nbBlancMod,nbNoirMod,frontMod);                                                                                            if analyseIntegraleDeFinale                      then valXY := CalculParAnalyseDeFinale(Xcourant)                      else valXY := {SSS_Dual(Xcourant);}                                  {calculNormal(Xcourant);}                                  Dicho_first(Xcourant);                  end;            end;                    {$IFC not(GENERATING68K) }          RemettreDansLaListeChaineeDesCasesVides(XCourant);          {$ENDC}                    TempsDeXCourant := classAux[compteur].temps+(TickCount()-TickChronoPourClassaux);          NotePourLeTriDeXCourant := NoteMilieuDeXCourant+((200*(TickCount()-TickChronoPourClassaux)) div 60);                    if not(bestMode) & (valXY<0) then valXY := -1;          if bestMode & passeDeRechercheAuMoinsNulle & (valXY<0) then            if not(analyseRetrograde.enCours) | (xCourant<>coupDontLeScoreEstConnu)              then                 begin                  if valXY>MaxConnuSiToutEstPerdant then                     MaxConnuSiToutEstPerdant := valXY;                  valXY := -1;                end;          if bestMode & (valXY>0) & odd(valXY) then inc(valXY);          if bestMode & not(analyseIntegraleDeFinale) & (valXY<bestAB) then valXY := bestAB;          if (interruptionReflexion<>pasdinterruption) then valXY := -infini;          if (valXY>bestAB) | ((valXY=bestAB) & (valXY=-1) & not(bestMode)) then             begin              bestAB := valXY;               if not(bestMode & passeDeRechercheAuMoinsNulle & (valXY<0)) then                GestionMeilleureSuite(miniprof,platmod,coulDefense,nbBlancMod,nbNoirMod,                                      valXY,Xcourant,compteur,longClass);                          end;                                if valxy>classAux[1].note then indice_du_meilleur := compteur;                                        if (analyseRetrograde.enCours & (analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeParfait) &               passeDeRechercheAuMoinsNulle & (compteur>=2) & (valXY<0)) |             (analyseRetrograde.enCours & (analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeGagnant) &               passeDeRechercheAuMoinsNulle & (compteur>=2) & (valXY<0))            then k := 2            else k := 1;          while (classAux[k].note>=valxy) & (k<compteur) do k := k+1;          for j := compteur downto k+1 do classAux[j] := classAux[j-1];          classAux[k].x := xcourant;          classAux[k].note := ValXY;          classAux[k].def := defense;          classAux[k].temps := TempsDeXCourant;          classAux[k].noteMilieuDePartie := NoteMilieuDeXCourant;          classAux[k].notePourLeTri := NotePourLeTriDeXCourant;          classAux[k].delta := kDeltaFinaleInfini;                    (***  tri suivant le classement au (milieu + 100*temps) si tous perdants  ***)          if (not(bestMode) | passeDeRechercheAuMoinsNulle) then           if (valXY < 0) & (bestAB<0) & (valXY>=bestAB) then             begin              if (analyseRetrograde.enCours & (analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeParfait) &                   passeDeRechercheAuMoinsNulle & (compteur>=2) & (valXY<0)) |                 (analyseRetrograde.enCours & (analyseRetrograde.genreAnalyseEnCours=ReflRetrogradeGagnant) &                   passeDeRechercheAuMoinsNulle & (compteur>=2) & (valXY<0))                then k := 2                else k := 1;              {while (classAux[k].temps>=TempsDeXCourant) & (k<compteur) do k := k+1;}              while (classAux[k].notePourLeTri>=NotePourLeTriDeXCourant) & (k<compteur) do k := k+1;              for j := compteur downto k+1 do classAux[j] := classAux[j-1];              classAux[k].x := xcourant;              classAux[k].note := ValXY;              classAux[k].def := defense;              classAux[k].temps := TempsDeXCourant;              classAux[k].noteMilieuDePartie := NoteMilieuDeXCourant;              classAux[k].notePourLeTri := NotePourLeTriDeXCourant;              classAux[k].delta := kDeltaFinaleInfini;            end;                    if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);                    if doitEcrireReflexFinale then            begin              if compteur<longClass then classAux[compteur+1].note := -notemax;              if not(bestMode)                then                   if analyseRetrograde.enCours                    then SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflRetrogradeGagnant,noCoupRecherche,compteur+1)                    else                      if typeCalculFinale=ReflPseudo                       then SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflPseudo,noCoupRecherche,compteur+1)                       else SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflGagnant,noCoupRecherche,compteur+1)                else                  if analyseRetrograde.enCours                    then SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflRetrogradeParfait,noCoupRecherche,compteur+1)                    else SetValReflexFinale(classAux,miniprof,compteur,longClass,ReflParfait,noCoupRecherche,compteur+1);            end;          if affichageReflexion.doitAfficher & doitEcrireReflexFinale then EcritReflexion;          if not(RefleSurTempsJoueur) & (jeuCourant[Xcourant]=PionVide) & pionclignotant then            EffacePionMontreCoupLegal(xcourant);                              if avecRefutationsDansRapport & commentaireDansRapport &            not(bestMode) & (compteur>=longClass) & (bestAB<0) then               EcritRefutationsDansRapport(longClass,classAux);                    if (valxy=64) then             begin              CoupGagnantOld := true;              meilleurScore := valXY;              sortieDeBoucle := true;              toutesLesPassesTerminees := true;            end;          if (not(bestMode) & (valXY > 0)) then            begin              CoupGagnantOld := true;              meilleurScore := valXY;              classAux[1].x := xcourant;              classAux[1].note := ValXY;              classAux[1].def := defense;              classAux[1].delta := kDeltaFinaleInfini;              classAux[2].note := ValXY-100;              if not(analyseIntegraleDeFinale) then sortieDeBoucle := true;            end;          if bestMode & (valXY=MaxConnuSiToutEstPerdant) & (betaAB=MaxConnuSiToutEstPerdant+1) then            begin              CoupGagnantOld := false;              meilleurScore := valXY;              sortieDeBoucle := true;            end;       end;                  until sortieDeBoucle | (compteur>=longClass) | (interruptionReflexion<>pasdinterruption);              if bestMode & passeDeRechercheAuMoinsNulle       then        begin            passeDeRechercheAuMoinsNulle := false;          if analyseRetrograde.enCours            then bestAB := scoreDuCoupDontLeScoreEstConnu            else bestAB := -64;          betaAB := succ(MaxConnuSiToutEstPerdant); {on sait que tous les coups sont perdants}        end      else        toutesLesPassesTerminees := true;    until toutesLesPassesTerminees | (interruptionReflexion<>pasdinterruption);         if (interruptionReflexion=pasdinterruption) then  begin    if CoulPourMeilleurFin=pionNoir      then scoreNoirBlanc := classAux[1].note      else scoreNoirBlanc := -classAux[1].note;    if analyseRetrograde.enCours      then MetScorePrevuDansCourbe(noCoupRecherche,noCoupRecherche,bestMode,scoreNoirBlanc)      else MetScorePrevuDansCourbe(noCoupRecherche,60,bestMode,scoreNoirBlanc);    SauvegardeLigneOptimale(coulDefense);    for i := 1 to longClass do class[i] := classAux[i];    MinimaxFinale := class[1].note;    if commentaireDansRapport & ((miniprof+1)<=8) then      MeilleureSuiteDansRapport;  end  else  { si (interruptionReflexion<>pasdinterruption) }    begin      if compteur<=1        then         begin           for i := 1 to longClass do class[i] := class[i];{on ne fait rien : on utilise le milieu de partie}           MinimaxFinale := class[1].note;         end       else         begin           for i := 1 to compteur-1 do class[i] := classAux[i];           for i := compteur to longClass do             class[i].note := class[compteur-1].note-100;           MinimaxFinale := class[1].note;           if commentaireDansRapport & ((miniprof+1)<=8) then             MeilleureSuiteDansRapport;         end;    end;  end;end;function Algo_Directionnel(coulPourMeilleurFin,nbbl,nbno:longint;jeu:plOth;var meilleurX:integer):longint;begin  if interruptionReflexion<>pasdinterruption then    begin      Algo_Directionnel := -30000;      meilleurX := 0;      bstdef := 0;      exit(Algo_Directionnel);    end;    PreordonnancementDesCoups;	    	if interruptionReflexion<>pasdinterruption then    begin      Algo_Directionnel := -30000;      meilleurX := classement[1].x;	    bstdef := classement[1].def;      exit(Algo_Directionnel);    end;    	    	 	if coulPourMeilleurFin=aQuiDeJouer 	  then EcritAnnonceFinaleDansMeilleureSuite(typeCalculFinale,noCoupRecherche,kDeltaFinaleInfini);  if doitEcrireReflexFinale then    case typeCalculFinale of       ReflPseudo:         SetValReflex(classement,MFniv,nbCoup,nbCoup,reflAnnoncePseudo,noCoupRecherche,maxint);       ReflGagnant,ReflRetrogradeGagnant:         SetValReflex(classement,MFniv,nbCoup,nbCoup,reflAnnonceGagnant,noCoupRecherche,maxint);       ReflParfait,ReflRetrogradeParfait:         SetValReflex(classement,MFniv,nbCoup,nbCoup,reflAnnonceParfait,noCoupRecherche,maxint);       otherwise         SetValReflex(classement,MFniv,nbCoup,nbCoup,reflAnnonceGagnant,noCoupRecherche,maxint);     end;  if affichageReflexion.doitAfficher & doitEcrireReflexFinale then EcritReflexion;    tempsAlloue := CalculeTempsAlloueEnFinale(CoulPourMeilleurFin);  SetValeursGestionTemps(tempsAlloue,0,0,0.0,0,0);  LanceChrono;  LanceChronoCetteProf;  if afficheGestionTemps & (interruptionReflexion=pasdinterruption) then EcritGestionTemps;  meilleurScore := MinimaxFinale(coulPourMeilleurFin,MFniv,nbCoup,nbbl,nbno,jeu,empl,frontiereFinale,classement);    if afficheGestionTemps & (interruptionReflexion=pasdinterruption) then EcritGestionTemps;  { on renvoie le premier du classement }  meilleurX := classement[1].x;  bstdef := classement[1].def;  Algo_Directionnel := classement[1].note;end;begin          {meilleurFinale};  kWNESleep := 0;  case typeCalculFinale of    ReflGagnant :       begin         bestMode := false;         analyseIntegraleDeFinale := false;       end;    ReflParfait :       begin         bestMode := true;         analyseIntegraleDeFinale := false;       end;    ReflParfaitExhaustif :       begin         bestMode := true;         analyseIntegraleDeFinale := true;       end;    ReflRetrogradeParfait :       begin         bestMode := true;         analyseIntegraleDeFinale := false;       end;    ReflRetrogradeGagnant :       begin         bestMode := false;         analyseIntegraleDeFinale := false;       end;    ReflPseudo :       begin         bestMode := false;         analyseIntegraleDeFinale := false;       end;    otherwise      begin        bestMode := false;        analyseIntegraleDeFinale := false;      end;  end;  commentaireDansRapport := commentaireDansRapport & not(jeuInstantane);  rechercheDejaAnnonceeDansRapport := false;  doitEcrireReflexFinale := true;  noCoupRecherche := nbBl+nbNo-4+1;  coulPourMeilleurFin := couleurFinale;  coulDefense := -coulPourMeilleurFin;   {  if avecEvaluationTotale then     if (couleur=aQuiDeJouer)       then         begin           analyseIntegraleDeFinale := true;           doitEcrireReflexFinale := true;         end       else         begin           analyseIntegraleDeFinale := false;           doitEcrireReflexFinale := false;         end;     }      ResultatSansCalcul := false;   if bestMode & not(analyseRetrograde.enCours) then     if PeutCalculerFinaleOptimaleParOptimalite(jeu,nbNo,nbBl,meilleurX,bstdef,scoreNoirBlanc)       then         begin           ResultatSansCalcul := true;           CoupGagnantOld := ((scoreNoirBlanc>=0) & (coulPourMeilleurFin=pionNoir)) |                         ((scoreNoirBlanc<=0) & (coulPourMeilleurFin=pionBlanc));           if coulPourMeilleurFin=pionNoir             then meilleurScore := scoreNoirBlanc             else meilleurScore := -scoreNoirBlanc;           if analyseRetrograde.enCours             then MetScorePrevuDansCourbe(noCoupRecherche,noCoupRecherche,bestMode,scoreNoirBlanc)             else MetScorePrevuDansCourbe(noCoupRecherche,60,bestMode,scoreNoirBlanc);                        exit(CoupGagnantOld);            end;       if usingEndgameTrees then     begin       SearchPositionFromThisNode(MakePositionEtTrait(jeu,coulPourMeilleurFin),gameTreeNode,endgameNode);       AllocateNewEndgameTree(endgameNode,magicCookieEndgameTree);     end;          if not(ResultatSansCalcul) then       begin                if commentaireDansRapport & InfosTechniquesDansRapport & (noCoupRecherche<43) then           AnnonceRechercheDansRapport(noCoupRecherche);                  infini := 30000;    {pas notemax pour eviter l'overflow}         MFniv := MFprof-1;         MyFillchar(@suiteJouee,sizeof(suiteJouee),chr(0));         MyFillchar(@meilleureSuite,sizeof(meilleureSuite),chr(0));         MyFillchar(@ListeKiller,sizeof(ListeKiller),chr(0));         MyFillchar(@classement,sizeof(classement),chr(0));         MyFillchar(@casesVidesSC,sizeof(casesVidesSC),chr(0));         MyFillchar(@casesVides,sizeof(casesVides),chr(0));         MyFillchar(@listeCasesVidesOrdreJCW,sizeof(listeCasesVidesOrdreJCW),chr(0));         MyFillchar(@coinsvides,sizeof(coinsvides),chr(0));         MyFillchar(@quadrantEstImpair,sizeof(quadrantEstImpair),chr(0));         MyFillchar(@nbVidesQuadr,sizeof(nbVidesQuadr),chr(0));         MyFillchar(@fils,sizeof(fils),chr(0));         TempsglobalDeLaFonction := TickCount();         nbreToursNoeudsGeneresFinale := 0;         nbreNoeudsGeneresFinale := 0;         MyFillchar(@NbreDeNoeudsMoyensFinale,sizeof(NbreDeNoeudsMoyensFinale),chr(0));         if not(analyseRetrograde.enCours) then            begin             VideToutesLesHashTablesExactes;             {for i := 0 to nbTablesHashExactes-1 do               WritelnStringAndReelDansRapport('taux_remplissage['+NumEnString(i)+']=',TauxDeRemplissageHashExacte(i,true),5);               }           end;         VideHashTable(HashTable);         InitialiseConstantesCodagePosition;         nbcasesvidesSC := 0;         nbcasesvides := 0;         nbcoinsvides := 0;         nbCoinsVidesPlus1 := 0;         nbCoinsVidesPlus2 := 0;         profForceBrute := 6;         profForceBrutePlusUn := profForceBrute+1;         profTriSelonDivergence := 8;         profMinimalePourClassementParMilieu := 16;                  tempsAlloue := CalculeTempsAlloueEnFinale(CoulPourMeilleurFin);         LanceChrono;                          for i := 1 to 4 do       {les coins}         BEGIN          iCourant := othellier[i];          if jeu[iCourant]=pionVide then            begin              nbcoinsvides := nbcoinsvides+1;              coinsvides[nbcoinsvides] := iCourant;            end;         end;         for i := 5 to 64 do       {sans les coins}         BEGIN          iCourant := othellier[i];          if jeu[iCourant]=pionVide then            begin              nbcasesvidesSC := nbcasesvidesSC+1;              casesVidesSC[nbcasesvidesSC] := iCourant;            end;         end;         for i := 1 to 64 do              BEGIN          iCourant := othellier[i];          if jeu[iCourant]=pionVide then            begin              nbcasesvides := nbcasesvides+1;              casesVides[nbcasesvides] := iCourant;              quadrantEstImpair[numeroQuadrant[iCourant]] := not(quadrantEstImpair[numeroQuadrant[iCourant]]);              inc(nbVidesQuadr[numeroQuadrant[iCourant]]);            end;         end;         nbCoinsVidesPlus1 := nbcoinsvides+1;         nbCoinsVidesPlus2 := nbcoinsvides+2;         j := 0;         for i := 64 downto 1 do           begin             iCourant := worst2best[i];             if jeu[iCourant]=pionVide then               begin                 j := j+1;                 listeCasesVidesOrdreJCW[j] := iCourant;               end;           end;                  {$IFC not(GENERATING68K) }         CreerListeChaineeDesCasesVides(nbcasesVides,ListeChaineeCasesVides,tableDesPointeurs);         {$ENDC}                  if TickCount()-dernierTick>=delaiAvantDoSystemTask then DoSystemTask(aQuiDeJouer);                  if OthelloTorique            then CarteMoveTore(coulPourMeilleurFin,jeu,move,mob)           else CarteMove(coulPourMeilleurFin,jeu,move,mob);                    if (mob>1) | doitAbsolumentRamenerLaSuite then   {**** au moins deux coups jouables ****}         begin           if coulPourMeilleurFin=aQuiDeJouer              then EcritAnnonceFinaleDansMeilleureSuite(typeCalculFinale,noCoupRecherche,kDeltaFinaleInfini);                    nbcoup := 0;           for i := 1 to nbcoinsvides do             if move[coinsvides[i]]  then               begin                  nbCoup := nbCoup+1;                 classement[nbCoup].x := coinsvides[i];               end;           for i := 1 to nbcasesvidesSC do             if move[casesVidesSC[i]]  then               begin                  nbCoup := nbCoup+1;                 classement[nbCoup].x := casesVidesSC[i];               end;           for p := 0 to MFniv+1 do             begin               k := 0;               for i := 1 to nbcoinsvides do                 begin                    k := k+1;                   ListeKiller[p,k] := coinsvides[i];                 end;               for i := 1 to nbcasesvidesSC do                 begin                    k := k+1;                   ListeKiller[p,k] := casesVidesSC[i];                 end;             end;                           tempsAlloue := CalculeTempsAlloueEnFinale(CoulPourMeilleurFin);         SetValeursGestionTemps(tempsAlloue,0,0,0.0,0,0);         if afficheGestionTemps & (interruptionReflexion=pasdinterruption) then EcritGestionTemps;                              for i := 0 to nbMaxNiveaux do nbMaxCoupsEnvisages[i] := 10000;         if typeCalculFinale=ReflPseudo then           begin             for i := MFprof-1 downto MFprof-3 do nbMaxCoupsEnvisages[i] := 5;             for i := MFprof-4 downto MFprof-6 do nbMaxCoupsEnvisages[i] := 5;             for i := MFprof-6 downto 9        do nbMaxCoupsEnvisages[i] := 10000;             for i := 8        downto 0        do nbMaxCoupsEnvisages[i] := 10000;           end;                           nbNiveauxRemplissageHash := 6;         nbNiveauxHashExacte := 10;                  profondeurRemplissageHash := MFprof-nbNiveauxRemplissageHash;         ProfPourHashExacte := MFprof-nbNiveauxHashExacte;                  if ProfPourHashExacte<8 then ProfPourHashExacte := 8;         if profondeurRemplissageHash<7 then profondeurRemplissageHash := 7;         ProfUtilisationHash := Min(ProfPourHashExacte,profondeurRemplissageHash);                  tempsAlloue := CalculeTempsAlloueEnFinale(CoulPourMeilleurFin);                                        meilleurScore := algo_directionnel(coulPourMeilleurFin,nbbl,nbno,jeu,meilleurX);          {meilleurScore := algo_NegaCStar(-64,64,coulPourMeilleurFin,MFprof,nbbl,nbno,jeu,meilleurX);}          {meilleurScore := algo_SSSStar(-64,64,coulPourMeilleurFin,MFprof,nbbl,nbno,jeu,meilleurX);}          {meilleurScore := Algo_AlphaBetaBrut(-64,64,coulPourMeilleurFin,MFprof,nbbl,nbno,jeu,meilleurX);}                  {      WritelnstringandnumDansRapport('score=',meilleurScore);          WritelnstringandnumDansRapport('meilleurCoup=',meilleurX);     }                         CoupGagnantOld := (meilleurScore>=0);                             end          else             { sinon on cherche l'unique coup }            begin              for i := 1 to 64 do               if move[othellier[i]] then                 begin                    meilleurX := othellier[i];                    bstdef := 44;                    CoupGagnantOld := true;                    Meilleurscore := ScorePourUnSeulCoupLegal;                 end;                EcritMeilleureSuiteParOptimalite;               if analyseRetrograde.enCours then                 if messageHandle<>NIL then                   begin                     typeDataDansHandle := messageHandle^^.typeData;                     case typeDataDansHandle of                       ReflRetrogradeParfait : ;  {cas à traiter}                       ReflScoreDejaConnuFinale,ReflScoreDeCeCoupConnuFinale :                         if CoulPourMeilleurFin=pionNoir                           then scoreNoirBlanc := messageHandle^^.data[0]                           else scoreNoirBlanc := -messageHandle^^.data[0];                     end;                     MetScorePrevuDansCourbe(noCoupRecherche,noCoupRecherche,bestMode,scoreNoirBlanc);                   end;            end;                  ReinitilaliseInfosReflexion;         if affichageReflexion.doitAfficher & not(analyseIntegraleDeFinale) & doitEcrireReflexFinale then           EffaceReflexion;         if InfosTechniquesDansRapport & commentaireDansRapport & not(demo) then           begin             AnnonceRechercheDansRapport(noCoupRecherche);             MetInfosTechniquesDansRapport;           end;         EffaceAnnonceFinaleSiNecessaire;                           if HasGotEvent(everyEvent,theEvent,kWNESleep,NIL)              then TraiteEvenements             else TraiteNullEvent(theEvent);                         end;     if (interruptionReflexion<>pasdinterruption) then VideToutesLesHashTablesExactes;  if usingEndgameTrees then LibereEndgameTree(magicCookieEndgameTree);end;END.